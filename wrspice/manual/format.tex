\chapter{{\WRspice} Input Format}

% spInput.hlp:spinput 040619

%------------------------------------------------------------------------------
\section{Input Format}
\index{input format}
\label{inputformat}

In this document, text which is provided in {\vt typewriter} font
represents verbatim input to or output from the program.  Text
enclosed in square brackets ( [text] ) is optional in the given
example, as in optional command arguments, whereas other text should
be provided as indicated.  Text which is {\it italicized} should be
replaced with the necessary input, as described in the accompanying
text.

Input to {\WRspice} consists of ASCII text, using either Unix or
Microsoft Windows line termination methods.  Input is contained in one
or more files.  If more than one file name is provided to the {\cb
source} command, the file contents will be concatenated in the order
given, and/or split into multiple circuits if {\vt .newjob} lines are
found.

There is provision in the syntax for file inclusions (referencing the
content of another file) to arbitrary depth.  Once the input files are
read, the lines are logically assembled into a ``deck'' for each
circuit, and each line is sometimes referred to as a ``card'',
teminology reflecting the punched-card heritage of the program.

The first line of a deck is taken as a title line for any circuit
described in the deck.  If the deck does not define a circuit (it may
consist of commands text only), the title line is not used, but with a
few exceptions must be present in input.  The title line can contain
7-bit ASCII characters only.  If a character is found in the title
line with the most-significant bit set, the read is aborted, as this
is taken as binary input, and attempting to read a binary file would
generate a cascade or errors or crash the program.  Binary characters
can exist elsewhere in the file, if necessary for whatever reason.

One exception to the rule that the first line be a title line is if
the first line of text in a file starts with the characters ``{\vt
\#!}'', that line will be discarded when the file is read.  This
enables {\WRspice} input files to be self-executing using the
mechanisms of the UNIX shell.  For example, if the following line is
prepended to an input file
\begin{quote}
{\vt \#! wrspice}
\end{quote}
and the file is made executable, then typing the name of the file will
initiate {\WRspice} on the circuit contained in the file.

The remaining lines are either circuit element descriptions, or
``dotcards'', or blocks of text surrounded by dotcards.  The circuit
element lines define the devices found in the circuit, providing
connection points which define the circuit topology, and device
parameter values.  The dotcards are lines whose initial token is a
keyword starting with `.'.  These provide various control directives
and data for use in simulating the circuit, including device models. 
Some dotcards, such as {\vt .verilog} and {\vt .control} provide
blocks of lines in some other format, which is different form the
SPICE format and is described separately.

The order of the circuit definition and control lines is arbitrary,
except that continuation lines must immediately follow the line being
continued, and certain constructs contain blocks of lines, which may
be command scripts which must be ordered.

Certain special input file formats are recognized, such as operating
range analysis control files, and files generated by the {\Xic}
schematic capture front end.  Exceptions to the rule of arbitrary line
placement will be described in the sections describing these files.

Fields on an element line and most dotcards are delimited by white
space, a comma, an equal sign (`='), or left or right parentheses;
extra white space is ignored.

A line may be continued to the following line(s) in two ways.  If the
last character on a line is a backslash character ($\backslash$), the
``newline'' is effectively hidden, and the text on the following line
will be appended to the current line, however leading white space is
stripped from the continuing line.  If there is more than one
backslash at the end of the line, all will be stripped before the line
is joined to the following line.  The traditional SPICE line
continuation is also available, whereby a line may be continued by
entering a {\vt +} (plus) as the first non-white space character of
the following line, {\WRspice} will continue reading beginning with
the character that follows.

\index{name field}
\index{node names}
Devices and device models are given names in input for reference. 
These name fields must begin with a letter and cannot contain any
delimiters.  Circuit connection points (``nodes') are also given
arbitrary names, however these may start with or just be an integer. 
The ground node must be named ``{\vt 0}'' (zero), however.  Note that
``{\vt 00}'' (for example) and "{\vt 0}" are distinct in
{\WRspice}, but not in SPICE2.  Non-ground node names may have
trailing or embedded punctuation (but this is generally not
recommended).

%----------------------------------------------------
\subsection{Case Sensitivity}
\index{case sensitivity}
In {\WRspice}, case sensitivity of various object names and strings is
under program control.  Historically the following have all been case
sensitive in WRspice:

\begin{quote}
Function names.\\
User-defined function names.\\
Vector names.\\
.PARAM names.\\
Codeblock names.\\
Node and device names.\\
\end{quote}

By default, starting in release 3.2.4, function names and user-defined
function names were made case-insensitive.  Starting in release
3.2.15, parameter names were made case-insensitive.  Finally, in
3.2.16, the remaining categories were made case-insensitive.  Thus, in
present releases, all identifiers are case-insensitive.  This seems to
be the common practise in commercial simulators.

Case sensitivity must be established at program startup and can not be
changed during operation.  There are two ways to accomplish this:

\begin{enumerate}
\item{The ``{\vt -c}'' command line option.}
\item{The {\cb setcase} command called in a startup file.}
\end{enumerate}

%----------------------------------------------------
\subsection{Numeric Values}
\index{number field}
\label{number}

\index{scale factors}
A number field may be an integer field (12, -44), a
floating point field (3.14159), either an integer or floating point
number followed by an integer exponent (1E-14, 2.65e3), or either an
integer or a floating point number followed by one of the following
scale factors.  All of this is case-insensitive.

\begin{quote}
\begin{tabular}{ll}
\vt t & 1e12 \\
\vt g & 1e9 \\
\vt meg & 1e6 \\
\vt k & 1e3 \\
\vt mil & 25.4e-6 \\
\vt m & 1e-3 \\
\vt u & 1e-6 \\
\vt n & 1e-9 \\
\vt p & 1e-12 \\
\vt f & 1e-15 \\
\vt a & 1e-18 \\
\end{tabular}
\end{quote}


%----------------------------------------------------
\subsection{Units}
\index{units field}
\label{units}

Immediately following the number and multiplier is an optional units
string.  The units string is composed of the concatenation character
`{\vt \#}', unit specification abbreviations as listed with the {\cb
settype} command (see \ref{settype}), digit exponents, and possibly a
separation character `{\vt \_}' (underscore).  Giving the {\cb settype}
command without arguments will list the unit abbreviations known to
{\WRspice}.

The units string must start with a letter, or the concatenation or
separation character followed by a letter, or two concatenation
characters followed by a letter.  The string consists of a sequence of
abbreviations, each optionally followed by a digit exponent.  If the
concatenation character appears within the string, the abbreviations
that follow provide denominator units.  The same applies for the
separation character, only denominator units follow.  The
concatenation or separation character in this context is logically
equivalent to `{\vt /}'.

The initial concatenation character is almost always optional.  It is
needed when there would be possible misinterpretation, for example
{\vt 1.0F} is dimensionless 1e-15, whereas {\vt 1.0\#F} is 1.0 farads. 
If the initial concatenation character is immedaiately followed by
another concatenation character, then all dimensions that follow are
denominator units.

Some Examples:

\begin{tabular}{ll}
\vt 1.0\#F\#M2 & 1 farad per square meter\\
\vt 1.0\#F\_M2 & 1 farad per square meter\\
\vt 1.0F\_M2 &   1e-15 per square meter\\
\vt 1.0\#\#S &   1 Hz\\
\vt 1.0\_S &     1 Hz\\
\vt 1.2\#uA\#S & 1.2 microamps per second\\
\vt 1.2\#uA\_S & 1.2 microamps per second\\
\vt 1.2uA\_S &   1.2 microamps per second\\
\vt 1.2\#A\_S &  1.2 amps per second\\
\vt 1.2A\_S &    1.2 aHz  (attohertz)\\
\vt 1.2uVS &     1.2 microvolt-seconds\\
\end{tabular}

All multipliers and unit abbreviations are case-insensitive, but by
convention we use lower case for the multiplier and upper case for the
first letter of the unit abbreviation.

If the unit specifier contains an unrecognized character or
abbreviation, it is ignored, and the number is dimensionless.

Internal representations of numbers carry along the unit specifier,
which will appear in output, and will propagate through calculations. 
Thus, for example, a number specified in volts, divided by a number
specified in ohms, would yield a number whose specification is amps.

It is possible to use a different concatenation character.  If the
variable {\et units\_catchar} is set to a string consisting of a
single punctuation character, then this character becomes the
xoncatenation character.  Similarly, if the variable {\et
units\_sepchar} is set to a string consisting of a single punctuation
character, then this character becomes the separation character.


%------------------------------------------------------------------------------
\section{Variable Expansion in Input}
\index{shell variable expansion}
\index{variable substitution}

{\WRspice} provides a unique and very useful feature:  as the circuit
description is being read, any shell variable references found in the
element lines or most dotcards are expanded.  The reader should be
aware that just about any text within the circuit description can be
specified through the shell substitution mechanism.

Shell variables are tokens which begin with ``{\vt \$}'', that have
been previously defined within {\WRspice}.  They most often appear for
numeric values in the deck, and the actual value replaces the ``{\vt
\$}'' token.  These variables are evaluated as the circuit is read in,
or with the {\cb reset} command once the circuit is loaded.  The
variables must be known to the shell before the circuit is parsed, so
if they are defined in the input file, the definition must occur in
{\vt .exec} blocks or {\vt .options} lines, which are evaluated before
the circuit is parsed, and not {\vt .control} blocks, which are
evaluated after the circuit is parsed.  If the `{\vt \$}' is preceded
with a backslash (`$\backslash$'), the shell substitution is
suppressed, but the construct forms a comment delimiter so that the
remainder of the line is ignored.

\index{single-quote expansion}
\index{single-quoted expressions}

Another type of expansion, single-quote expansion, is also performed
as input is read.  This is most often used in {\vt .param} lines, and
is another means by which the circuit can be configured before
simulating through prior {\WRspice} operations.  Any text enclosed in
single quotes (') will be evaluated as an expression as the file is
read (before shell substitution) and the string will be replaced by
the result.  Since evaluation is performed before shell substitution,
the expression can not contain shell variables or other `{\vt \$}'
references, but it can contain vectors (which must be defined before
the circuit is read).


%------------------------------------------------------------------------------
\section{Title, Comments, Job Separation, and Inclusions}

% spInput.hlp:titleinc 121611

%----------------------------------------------------
\subsection{Title Line}
\index{title line}
The first line of the circuit description is a title line.  Any text
(including a blank line) can appear in the title line.  The line is
printed as part of generated output, but is otherwise unused by
{\WRspice}.

In the title line, the character sequences ``{\vt $\backslash$n}'' and
``{\vt $\backslash$t}'' are replaced with newline and tab characters,
respectively.  Thus, it is possible to have a title string that prints
multiple lines.  The title line always counts as a single line for
internal line numbering, however.

%----------------------------------------------------
\subsection{Comments}
\index{comment line}

\spgen{*{\it any comment}\\
any\_spice\_text $\backslash$\$ this text is ignored}
\spexamp{* rf=1k\hspace{1cm}gain should be 100\\
{\vt *}beginning of amplifier description \\
r1 1 0 100 $\backslash$\$ this is a comment}

In the circuit description, an asterisk (`{\vt *}') as the first
non-white space character indicates that this line is a comment line. 
Comments may be placed anywhere in the circuit description.  Also,
there is provision for adding comments to the end of a line.

Comment lines which begin with `{\vt *@}' and `{\vt *\#}' in the
circuit description are special:  they are taken as executable
statements as if included in {\vt .exec} or {\vt .control} blocks,
respectively (see \ref{control}).

Comments at the end of a line may be added as follows:
\begin{itemize}
\item{If the sequence ``{\vt $\backslash$\$}'' appears in a line of
  SPICE input and is preceded by white space or is at the beginning
  of the line, these and the characters that follow on the line are
  taken as a comment.}
\item{If an isolated `{\vt \$}' character is found, i.e., with
  white space or start of line preceding and white space
  following, The `{\vt \$}' and text that follows on the line
  will be taken as a comment.}
\item{If an isolated `{\vt ;}' character is found, i.e., with
  white space or start of line preceding and white space
  following, The `{\vt ;}' and text that follows on the line
  will be taken as a comment.}
\end{itemize}

In addition, for compatibility with other simulators, the {\et
dollarcmt} variable can be set.  When set, any `{\vt \$}' or `{\vt ;}'
character preceded by start of line, white space, or a comma, will be
taken as the start of a comment.

In {\vt .exec} and {\vt .control} blocks, comments are indicated for
lines with the first non-whitespace character being `{\vt \#}', for
compatibility with the shell.  In Verilog blocks, The C++ commenting
style (``{\vt //}'' for single line comments and ``{\vt /* ...  */}''
for multi-line comments) is recognized.

%----------------------------------------------------
\subsection{{\vt .title} Line}
\index{.title line}
\spgen{.title {\it any text}}
\spexampo{.title This is an alternate title}

This simply replaces the title line text in output.

%----------------------------------------------------
\subsection{{\vt .end} Line}
\index{.end line}
\spgen{.end}

This line is optional, but if it appears it should be the last line in
the circuit description part of the input file.  The {\vt .end} line
is ignored in {\WRspice}.

%----------------------------------------------------
\subsection{{\vt .newjob} Line}
\index{.newjob line}
\spgen{.newjob}

The {\vt .newjob} line is recognized in files directly read by
{\WRspice}, and {\bf not} in files read through {\vt .include}/{\vt
.lib} directives (see below).  When encountered during a {\cb source}
command, file parsing for the present circuit terminates, and lines
that follow are taken as belonging to a new circuit deck.  The script
execution and other operations that usually occur at the end of a {\cb
source} operation are done before parsing (for a new circuit) resumes.

Thus, one can place multiple circuit descriptions in a single file,
separated by {\vt .newjob} lines.  Sourcing the file is equivalent to
sourcing each circuit independently and sequentially.

With no {\vt .newjob} lines, when multiple files are listed on the
command line in batch mode, or given to the {\cb source} command, they
are simply concatenated.  With {\vt .newjob} lines, it is possible to
give multiple circuits within a single or several files.  {\WRspice}
will source the circuits as if they were given individually, in
sequence.  The circuits may or may not coincide with the physical
files -- lines in the files between {\vt .newjob} lines are
concatenated.  After a {\cb source} of multiple circuits, the current
circuit will be the last circuit read.

Batch mode is similar.  A single batch job can run multiple circuits. 
Logical circuts are read, run, and output generated, in sequence.  The
individual circuits can be concatenetated into a single file,
separated with {\vt .newjob} lines, or a {\vt .newjob} line can be
added to the top of the individual circuit files.  In the later case,
``{\vt wrspice -b} {\it file1} {\it file2} ...'' would run each
circuit in sequence.  If the {\vt .newjob} lines weren't present, {\it
WRspice} would attempt to run a concatenation of the files.  In batch
mode, since it is possible to run multiple circuits, the {\vt
.cache}/{\vt .endcache} feature can be used to advantage, without
using a command script.

The line that follows a {\vt .newjob} line is interpreted in exactly
the same way as the first line of an input file, i.e., it is
interpreted as a circuit title line except in a few cases.  If the
first line of an input file is a {\vt .newjob} line, it will be
ignored, except that when reading multiple files, it indicates that a
new circuit should start, rather than concatenation of the file to
previous input.

Although circuits run in this manner are independent, note that
variables set by scripts associated with a circuit, for example, would
remain set for the later circuits.  Thus, there are potential side
effects which must be considered.

The {\vt .cache}/{\vt .endcache} blocks work as they would in separate
files.  Only one cache block can appear in a circuit, but of course a
file containing multiple circuits can contain multiple cache blocks.

The {\vt .newjob} lines separate the input into separate groups of
lines, so one must take care to ensure that all related {\vt
.control}, {\vt .verilog}, etc., blocks and lines will appear in the
correct group.  There are no ``common'' lines.

%----------------------------------------------------
\subsection{{\vt .include} or {\vt .inc} Line}
\index{.include line}
\index{.inc line}
\index{.spinclude line}
\spgen{.include [h] {\it filename}\\
  .inc [h] {\it filename}}
\spexampo{.include models.def\\
  .inc /projects/data.inc\\
  .inc h /models/hspice\_models.inc}

The keywords ``{\vt .include}'' and ``{\vt .inc}'' are equivalent. 
The {\vt .include} line specifies that the named file is to be read
and added to the input at the location of the {\vt .include} line. 
Included files may be nested arbitrarily.

If the {\vt h} option (case insensitive) is given, the {\et dollarcmt}
variable is effectively set while the file, and any recursive
sub-files, are being read.  Thus, the HSPICE `{\vt \$}' comment syntax
will be recognized in the included files.  The {\et dollarcmt}
variable is reset to its prior value after the read.

This avoids having to explicitly set the {\et dollarcmt} variable when
reading files intended for HSPICE.  It allows the normal {\WRspice}
shell substitution to work with the file containing the include line,
which would not be the case if the {\et dollarcmt} variable was set
explicitly.

While the included file is being read, the current directory is pushed
to the directory containing the file.  Thus, {\vt .include} (and {\vt
.lib}) lines in the file will have paths resolveed relative to that
directory, and not the original current directory.

In {\WRspice}, the keyword {\vt .spinclude} is accepted as a synonym
for {\vt .include}.  This is for compatibility with {\Xic}, which will
replace {\vt .include} lines with the file contents, but will pass
{\vt .spinclude} lines to SPICE, after converting ``{\vt .spinclude}''
to ``{\vt .include}''.

These lines are shell expanded when encountered, before the indicated
file is accessed.  This allows the paths to include shell variables,
which can be set interactively.  Normal shell expansion, which applies
to all other lines, occurs after all includes are read, parameter
expansion, etc., much later in the sourcing process.  Note that shell
variables can't be used in files included with the `{\vt h}' option,
or when the {\et dollarcmt} variable is set, as the `{\vt \$}' will be
taken as the start of a comment.

%----------------------------------------------------
\subsection{{\vt .lib} Line}
\index{.lib line}
\index{.splib line}
\index{.endl line}
\spgen{.lib [h] {\it path\_to\_file name}}
\spexampo{.lib /usr/local/parts/mylib mos25\\
  .lib h /usr/cad/hspice\_models mymod}

This will look in {\it path\_to\_file} for lines enclosed as follows.
\begin{quote}
    {\vt .lib} {\it name}\\
    ... lines of SPICE text\\
    {\vt .endl}
\end{quote}
The lines inside the block will be read into the input deck being
parsed, similar to the {\vt .include} line.

If the {\vt h} option (case insensitive) is given, the {\et dollarcmt}
variable is effectively set while the file, and any recursive
sub-files, are being read.  Thus, the HSPICE `{\vt \$}' comment syntax
will be recognized in the text.  The {\et dollarcmt} variable is reset
to its prior value after the read.

This avoids having to explicitly set the {\et dollarcmt} variable when
reading files intended for HSPICE.  It allows the normal {\WRspice}
shell substitution to work with the file containing the {\vt .lib}
line, which would not be the case if the {\et dollarcmt} variable was
set explicitly.

While the file is being read, the current directory is pushed to the
directory containing the file.  Thus, {\vt .include} and {\vt .lib}
lines in the file will have paths resolveed relative to that
directory, and not the original current directory.

These lines are shell expanded when encountered, before the indicated
file is accessed.  This allows the paths or block names to include
shell variables, which can be set interactively.  Normal shell
expansion, which applies to all other lines, occurs after all includes
are read, parameter expansion, etc., much later in the sourcing
process.  Note that shell variables can't be used in files included
with the `{\vt h}' option, or when the {\et dollarcmt} variable is
set, as the `{\vt \$}' will be taken as the start of a comment.

The library file can contain any number of {\vt .lib} blocks.  The
{\vt .lib} block can itself contain {\vt .lib} references.  The text
can be any valid {\WRspice} input.  The {\it name} is an arbitrary text
token, which should be unique among the {\vt .lib} blocks in a library
file.

\spexampo{
     title line\\
     .lib /usr/stevew/spice/stuff/mylibrary mosblock\\
     {\rm ... more lines}}

    In {\vt /usr/stevew/spice/stuff/mylibrary}:
\begin{quote}\vt
    .lib mosblock\\
    m0 4 9 12 PSUB p1pvt l=0.25u w=2.4u\\
    .endl
\end{quote}

    is equivalent to:
\begin{quote}\vt
    title line\\
    m0 4 9 12 PSUB p1pvt l=0.25u w=2.4u\\
    {\rm ... more lines}
\end{quote}

In {\WRspice}, the keyword {\vt .splib} is accepted as a synonym for
{\vt .lib}.  This is for compatibility with {\Xic}, which will replace
{\vt .lib} lines with the block of text from the library, but will
pass {\vt .splib} lines to SPICE, after converting ``{\vt .splib}'' to
``{\vt .lib}''.

%----------------------------------------------------
\subsection{{\vt .mosmap} Line}
\index{.mosmap line}
\spgen{.mosmap [{\it ext\_level\/}] [{\it wrspice\_level\/}]}
\spexampo{.mosmap 127 14\\
  .mosmap}

This construct maps the level number found in MOS {\vt .model} lines
to another number in {\WRspice}.  Different SPICE simulators may
provide similar internal MOS model support, although with different
level numbers.  Although an attempt has been made in {\WRspice} to be
compatible with HSPICE level numbers, there may be differences, and
there is less commonality with other SPICE programs.  One can in
principle simply copy the model files and edit the level numbers to
those expected in {\WRspice}, but this may be inconvenient.

Suppose that you have a set of model files provided by a foundry
service, designed for another simulator.  These files provide
parameters for the Berkeley BSIM-4.4 model, with level 99 (as an
example).  In {\WRspice}, the BSIM-4.4 model is assigned to level 14. 
Rather than copying and editing the files, one can use to following
construct in the {\WRspice} input:

\begin{quote}
{\vt .mosmap 99 14}\\
{\vt .include} {\it path\_to\_model\_file}
\end{quote}

The level 99 as found in the model file will be interpreted as 
level 14 in {\WRspice}.

This line must appear logically ahead of, i.e., read before, the
corresponding {\vt .model} lines.  Any number of {\vt .mosmap} lines
can be used in the input.  The mapping applies while the file is being
read and is not persistent.

In the most common usage, {\vt .mosmap} is followed by two integers,
the first being the model level to map, and the second being a valid
MOS level number in {\WRspice}.  If only one number appears, any
mapping associated with that number is removed for the remainder of
the file read.  If no number appears, then all mappings are removed
for the remainder of the read.  These latter cases are probably
infrequently needed.

Note that the {\cb devmod} command in {\WRspice} can be used to change
device model levels, which may be more convenient than using {\vt
.mosmap}, and applies to all device types.


%------------------------------------------------------------------------------
\section{Initialization}

% spInput.hlp:initialize 060314

%----------------------------------------------------
\subsection{{\vt .global} Line}
\index{.global line}
\index{global nodes}
\spgen{.global {\it node1 node2} ...}

The arguments are node names.  These declared node names remain
unaltered when subcircuits are expanded, thus the indicated nodes
become accessible throughout the circuit.

For example, the substrate node of all n-channel MOSFETS in the main
circuit and subcircuits can be tied to a node listed in the {\vt
.global} line.  Then, substrate bias can be applied to all substrate
nodes with a single source, conveniently located in the main circuit.

%----------------------------------------------------
\subsection{{\vt .ic} Line}
\index{.ic line}
\label{icline}
\spgen{.ic {\vt v(}{\it nodname\/}{\vt )=}{\it val} |
  {\it nodename\/}{\vt=}{\it val} ...}
\spexampo{.ic v(11)=5 4=-5 v(2)=2.2}

This line is for setting transient initial conditions.  Note that the
``{\vt v( )}'' around the node name is optional.  It has two different
interpretations, depending on whether the {\vt uic} parameter is
specified on the {\vt .tran} line.  Also, one should not confuse this
line with the {\vt .nodeset} line.  The {\tt .nodeset} line is only to
help dc convergence, and does not affect final bias solution (except
for multi-stable circuits).  The two interpretations of this line are
as follows:

\begin{enumerate}
\item{ When the {\vt uic} parameter is specified on the {\tt .tran} line,
 then the node voltages specified on the {\vt .ic} line are used to
 compute the capacitor, diode, BJT, JFET, and MOSFET initial
 conditions.  This is equivalent to specifying the {\vt
 ic=}... parameter on each device line, but is much more convenient.
 The {\vt ic=}...  parameter can still be specified and will take
 precedence over the {\vt .ic} values.  Since no dc bias (initial
 transient) solution is computed before the transient analysis, one
 should take care to specify all dc source voltages on the {\vt .ic}
 line if they are to be used to compute device initial conditions. }

\item{ When the {\vt uic} parameter is not specified on the {\tt .tran}
 line, the dc bias (initial transient) solution will be computed
 before the transient analysis.  In this case, the node voltages
 specified on the {\vt .ic} line will be forced to the desired initial
 values during the bias solution.  During transient analysis, the
 constraint on these node voltages is removed. }
\end{enumerate}

%----------------------------------------------------
\subsection{{\vt .nodeset} Line}
\index{.nodeset line}
\index{convergence}
\spgen{.nodeset {\vt v(}{\it nodname\/}{\vt )=}{\it val} |
  {\it nodename\/}{\vt=}{\it val} ...}
\spexampo{.nodeset v(12)=4.5 v(4)=2.23}

This line helps the program find the dc or initial transient solution
by making a preliminary pass with the specified nodes held to the
given voltages.  The restriction is then released and the iteration
continues to the true solution.  The {\vt .nodeset} line may be
necessary for convergence of bistable or astable circuits.  In
general, this line should not be necessary.  Note that the ``{\vt v(
)}'' around the node name is optional.

%----------------------------------------------------
\subsection{{\vt .options} Line}
\index{.options line}
\index{spice options}
\index{options}
\spgen{.options {\it opt1 opt2\/} ... (or {\it opt=optval\/} ...)}
\spexampo{.options reltol=.005 trtol=8}

Options which control the operation of the simulator can be entered in
the {\WRspice} input file following the {\vt .options} keyword.  In
{\WRspice} there are a number of variables which control simulation,
many familiar from traditional Berkeley SPICE.  Any variable can be
set on the {\vt .options} line, and this is similar to setting the
variable from the shell with the {\cb set} command, however the
variables set from the {\vt .options} line are active only when the
circuit is the current circuit, and they can not be unset with the
{\cb unset} command.

Multiple {\vt .options} lines can appear in input.  The lines are
shell-expanded and evaluated in top-to-bottom order, and left-to-right
for each line.  The {\vt .options} lines are expanded and evaluated
after execution of the {\vt .exec} lines.  The result of processing
each option is immediately available, so that lines like
\begin{quote}\vt
  .options aaa=1 bbb=\$aaa\\
  .options random tmpval = \$\&(gauss(.2,1))
\end{quote}
will work.  In the second line, the variable {\et random} will be set
when the {\vt gauss} function is evaluated, so that it will return a
random value, and not just the mean.

The variables set in the {\vt .options} lines are set before variable
expansion is performed on the rest of the circuit text, so that global
shell variables may be set in the {\vt .options} lines.

The options which control simulation can also be entered from the
keyboard by using the {\WRspice} {\cb set} command, or equivalently
from the graphical tools available from the {\cb Tools} menu of the
{\cb Tool Control} window (described in \ref{tcwin}), in particular
the {\cb Simulation Options} tool.

Before a simulation starts, variables set in the shell and variables
set in {\vt .options} lines are merged according to a rule as to how
to resolve inconsistencies.  The details of the merging process are
described in the next section, which lists the recognized circuit
options.  This section provides further information on the use of
option variables in {\WRspice}.

%----------------------------------------------------
% spVars_sim.hlp:options 011821

\subsubsection{Simulation Options}
\label{options}
\index{.options line}
\index{spice options}
\index{options}

In any SPICE-like program, the {\vt .options} line in input allows
setting of variables and flags that control aspects of the simulation
run.  {\WRspice} provides this support as well, however in a more
general context as there is little difference between ``options'' and
``variables'', as set with the {\cb set} command.  In {\WRspice}, an
``option'' is simply a variable set in the {\vt .options} line of an
input file that has been sourced.

The options are stored in a table within the circuit structure, and
are in force when the circuit is the current circuit.  In the listing
or variables provided from the {\cb set} command given with no
arguments, or in the {\cb Variables} tool from the {\cb Tools} menu in
the {\cb Tool Control} window, the option variables that are in force
are indicated with a `{\vt +}' in the first column.

The variables set in the {\vt .options} line may be available for
substitution (into {\vt \$}{\it variable} references) when the circuit
is the current circuit, but otherwise do not affect the shell.  For
example, setting the variable {\vt noglob} from a {\vt .options} line
will {\it not} affect the global expansion of the shell, but
references to {\vt \$noglob} would behave as if the boolean {\vt
noglob} was set, while the circuit is the current circuit.

Shell variables set in the {\vt .options} line are set before the rest
of the SPICE text is expanded, so that shell variable references in
the text can be defined from the {\vt .options} line, as in the {\vt
.exec} block.  The {\vt .exec} lines are executed before the {\vt
.options} lines are expanded.

Since options can be set in the shell, as well as from the circuit,
{\WRspice} must merge the two sets of variables according to some
rule.  The rule allows three variations:

\begin{enumerate}
\item{{\vt global} mode (the default)\\
In global options merging, if a boolean variable is set in either the
circuit or the shell, it is taken as set.  If a non-boolean variable
is set in only one of the circuit or the shell, the variable is taken
as set using the given value.  If a non-boolean variable is set in
both the circuit and the shell, the shell value will be used.

This is the default mode, and the only mode available in Berkeley
SPICE3.  This allows the interactive user to use the {\cb set} command
to override options set in the circuit file.  This may also be
somewhat dangerous, as the shell override may occur for a forgotten
variable, causing the user to wonder about strange results.}

\item{{\vt local} mode\\
This is similar to {\vt global} mode, except that in the case of a
non-boolean variable being defined in both the circuit and the shell,
the circuit definition will apply.

In this mode, the {\cb set} command can be used to set circuit
variables that were not defined on {\vt .options} lines in the circuit
file.  The {\cb set} command will have no effect on variables that
were defined in this way.}

\item{{\vt noshell} mode\\
In this mode, the circuit will ignore variables set in the shell, and
apply only variables set in {\vt .options} lines.  This applies,
however, only to the set of variables that affect circuit setup or
simulation, as listed in the table below.  It also only applies during
the actual circuit setup and simulation runs.  It does {\bf not} apply
when the shell is running commands, such as from {\vt .control} and
{\vt .exec} lines, or other scripts.  The mode is taken as {\vt local}
in these cases.}
\end{enumerate}

There are two variables which control the option merging mode.  Both,
like any variables, can be set from the shell or from the circuit via
{\vt .options} lines.

\begin{description}
\item{\vt optmerge}\\
This variable can be set to one of three string constants:  ``{\vt
global}'', ``{\vt local}'', or ``{\vt noshell}''.

\item{\vt noshellopts}\\
This boolean variable is deprecated.  When set, it will override {\vt
optmerge} if also given, and force the ``{\vt noshell}'' mode.
\end{description}.

If set in both the shell and the circuit, resolution is according
to these rules.

\begin{itemize}
\item{If {\vt noshellopts} is set in the circuit or from the
shell, it will be in effect, setting {\vt noshell} mode.}

\item{Otherwise, if {\vt optmerge} is set to ``{\vt noshell}'' in
either the circuit or the shell, {\vt noshell} mode will be in effect.}

\item{Otherwise, if {\vt optmerge} is set to ``{\vt local}'' in either
the circuit or the shell, {\vt local} mode will be in effect.}

\item{Otherwise, the {\vt global} mode is in effect.}
\end{itemize}

The table below is a listing of the ``official'' options.  What makes
these variables official options is that most of these set a flag or
value in the circuit data structure, which is used when simulations
are run.  This is in addition to the setting of the variable in the
normal database for variables, which is used for shell variable
substitution, etc.  From the user's perspective, there is no real
distinction between ``options'' and ``variables''.  A complete
description of each of these variables is provided in \ref{simvars}.

\begin{longtable}{|p{1in}|p{4.75in}l|}\hline
\bf Parameter Name & \bf Description&\\ \hline
\multicolumn{3}{|l}{ }\\
\multicolumn{3}{|l}{\bf Real-Valued Parameters}\\ \hline
{\vt abstol} & \rr The absolute current error tolerance of the program.&\\ \hline
{\vt chgtol} & \rr The minimum charge used when computing the time step in
  transient analysis.&\\ \hline
{\vt dcmu} & \rr Mixing parameter to help dc convergence.&\\ \hline
{\vt defad} & \rr The default value for MOS drain diffusion area.&\\ \hline
{\vt defas} & \rr The default value for MOS source diffusion area.&\\ \hline
{\vt defl} & \rr The value for MOS channel length.&\\ \hline
{\vt defw} & \rr The value for MOS channel width.&\\ \hline
{\vt delmin} & \rr The minimum time step allowed.&\\ \hline
{\vt dphimax} & \rr The maximum allowed phase change per time step.&\\ \hline
{\vt jjdphimax} & \rr An alias for {\vt dphimax}.&\\ \hline
{\vt gmax} & \rr The maximum conductance allowed in circuit equations.&\\ \hline
{\vt gmin} & \rr The minimum conductance allowed in circuit equations.&\\ \hline
{\vt maxdata} & \rr Maximum output data size in kilobytes.&\\ \hline
{\vt minbreak} & \rr The minimum time, in seconds, between breakpoints.&\\ \hline
{\vt pivrel} & \rr The relative ratio between the largest column entry and
  an acceptable pivot value.&\\ \hline
{\vt pivtol} & \rr The absolute minimum value for a matrix entry to be
  accepted as a pivot.&\\ \hline
{\vt rampup} & \rr Time to ramp up sources in transient analysis.&\\ \hline
{\vt reltol} & \rr The relative error tolerance of the program.&\\ \hline
{\vt temp} & \rr The assumed circuit operating temperature.&\\ \hline
{\vt tnom} & \rr The nominal temperature for device model parameters.&\\ \hline
{\vt trapratio} & \rr The threshold for trapezoidal integration
  convergence failure detection.&\\ \hline
{\vt trtol} & \rr The transient time step prediction factor, the
  approximate overestimation of the actual truncation error.&\\ \hline
{\vt vntol} & \rr The absolute voltage error tolerance of the program.&\\ \hline
{\vt xmu} & \rr The SPICE2 trapezoidal/Euler mixing parameter.&\\ \hline

\multicolumn{3}{|l}{ }\\
\multicolumn{3}{|l}{\bf Read-Only Real-Valued Parameters}\\ \hline
{\vt delta} & \rr Transient analysis internal time step.&\\ \hline
{\vt fstart} & \rr AC analysis start frequency.&\\ \hline
{\vt fstop} & \rr AC analysis end frequency.&\\ \hline
{\vt maxdelta} & \rr Transient analysis maximum internal time step.&\\ \hline
{\vt tstart} & \rr Transient analysis start output time.&\\ \hline
{\vt tstep} & \rr Transient analysis print increment.&\\ \hline
{\vt tstop} & \rr Transient analysis final time.&\\ \hline

\multicolumn{3}{|l}{ }\\
\multicolumn{3}{|l}{\bf Integer-Valued Parameters}\\ \hline
{\vt bypass} & \rr Set to 0 to disable element computation bypassing.&\\ \hline
{\vt fpemode} & \rr Set floating point error handling method (0--3).&\\ \hline
{\vt gminsteps} & \rr The number of increments to use for non-dynamic gmin
  stepping.&\\ \hline
{\vt interplev} & \rr The interpolation level used for scale data.&\\ \hline
{\vt itl1} & \rr The dc operating pointiteration limit.&\\ \hline
{\vt itl2} & \rr The dc transfer curve iteration limit.&\\ \hline
{\vt itl2gmin} & \rr The iteration limit that applies during gmin stepping.&\\ \hline
{\vt itl2src} & \rr The iteration limit that applies during source stepping.&\\ \hline
{\vt itl4} & \rr The transient timepoint iteration limit.&\\ \hline
{\vt loadthrds} & \rr The number of helper threads used for device
  evaluation and matrix loading.&\\ \hline
{\vt loopthrds} & \rr The number of helper threads used when performing
  repeated analysis.&\\ \hline
{\vt maxord} & \rr The maximum integration order.&\\ \hline
{\vt srcsteps} & \rr The number of increments to use for non-dynamic source
  stepping.&\\ \hline
{\vt itl6} & \rr An alias for {\vt srcsteps}.&\\ \hline
{\vt vastep} & \rr Verilog time step mapping.&\\ \hline

\multicolumn{3}{|l}{ }\\
\multicolumn{3}{|l}{\bf Boolean Parameters}\\ \hline
{\vt dcoddstep} & \rr Always include range end point in dc sweep.&\\ \hline
{\vt extprec} & \rr Use extended precision when solving circuit equations.&\\ \hline
{\vt forcegmin} & \rr Enforce all nodes mave at least gmin conductivity to
  ground.&\\ \hline
{\vt gminfirst} & \rr Attempt gmin stepping before source stepping.&\\ \hline
{\vt hspice} & \rr Suppress warnings from unsupported HSPICE input.&\\ \hline
{\vt jaccel} & \rr Attempt to speed up Josephson junction transient
  analysis.&\\ \hline
{\vt noiter} & \rr Don't Newton iterate.&\\ \hline
{\vt nojjtp} & \rr >Don't use Josephson junction time step limiting.&\\ \hline
{\vt noklu} & \rr Don't use KLU sparse matrix solver, use SPICE3 Sparse.&\\ \hline
{\vt nomatsort} & \rr With Sparse solver, don't sort elements for cache
  locality.&\\ \hline
{\vt noopiter} & \rr Skip initial dc convergence attempt.&\\ \hline
{\vt nopmdc} & \rr Do not allow phase-mode DC analysis.&\\ \hline
{\vt noshellopts} & \rr Ignore circuit variables not set in {\vt .options}
  line.&\\ \hline
{\vt oldlimit} & \rr Use SPICE2 voltage limiting.&\\ \hline
{\vt oldsteplim} & \rr Use SPICE3/{\WRspice}-3 timestep limiting.&\\ \hline
{\vt renumber} & \rr Renumber lines after subcircuit expansion.&\\ \hline
{\vt savecurrent} & \rr Save device current special vectors.&\\ \hline
{\vt spice3} & \rr Use the SPICE3 integration level control logic
  in transient analysis.&\\ \hline
{\vt trapcheck} & \rr Perform trapezoidal integration convergence testing in
  transient analysis.&\\ \hline
{\vt trytocompact} & Enable compaction in LTRA (lossy transmission line)
  model.&\\ \hline
{\vt useadjoint} & \rr Create an adjoint matrix for BSIM device current
  monitoring.&\\ \hline
{\vt translate} & \rr Map node numbers into matrix assuming nodes are not
  compact.&\\ \hline

\multicolumn{3}{|l}{ }\\
\multicolumn{3}{|l}{\bf String Parameters}\\ \hline
{\vt method} & \rr Integration method: ``{\vt trap}'' (default) or
  ``{\vt gear}''.&\\ \hline
{\vt optmerge} & \rr Options merging method: ``{\vt global}'' (default) or
  ``{\vt local}'' or ``{\vt noshell}''.&\\ \hline
{\vt parhier} & \rr Parameter substitution precedence: ``{\vt global}''
  (default) or ``{\vt local}''.&\\ \hline
{\vt steptype} & \rr Time advancement method: ``{\vt interpolate}'' (default)
  or ``{\vt hitusertp}'', ``{\vt nousertp}'', ``{\vt fixedstep}''.&\\ \hline
{\vt tjm\_path} & \rr Amplitude table file search path for Josephson 
 junction model.&\\ \hline

\multicolumn{3}{|l}{ }\\
\multicolumn{3}{|l}{\bf Batch and Output Parameters}\\ \hline
{\vt acct} & \rr Print accounting information in batch output.&\\ \hline
{\vt dev} & \rr Print device list in batch output.&\\ \hline
{\vt list} & \rr Print a listing of the input file in batch output.&\\ \hline
{\vt mod} & \rr Print device model list in batch output.&\\ \hline
{\vt node} & \rr Print a tabulation of the operating point node voltages in
  batch output.&\\ \hline
{\vt nopage} & \rr Suppress page breaks in batch output.&\\ \hline
{\vt numdgt} & \rr Number of significant digets printed in output.&\\ \hline
{\vt opts} & \rr Print a summary of the specified options in batch output.&\\ \hline
{\vt post} & \rr Give post-simulation option.&\\ \hline

\multicolumn{3}{|l}{ }\\
\multicolumn{3}{|l}{\bf Obsolete/Unsupported Parameters}\\ \hline
{\vt cptime} & \rr Obsolete SPICE2 parameter.&\\ \hline
{\vt itl3} & \rr Obsolete SPICE2 parameter.&\\ \hline
{\vt itl5} & \rr Obsolete SPICE2 parameter.&\\ \hline
{\vt limpts} & \rr Obsolete SPICE2 parameter.&\\ \hline
{\vt limtim} & \rr Obsolete SPICE2 parameter.&\\ \hline
{\vt lvlcod} & \rr Obsolete SPICE2 parameter.&\\ \hline
{\vt lvltim} & \rr Obsolete SPICE2 parameter.&\\ \hline
{\vt nomod} & \rr Obsolete SPICE2 parameter.&\\ \hline

\end{longtable}

%----------------------------------------------------
\subsection{{\vt .table} Line}
\index{.table line}
\spgen{.table {\it name} {\vt [ac]} $x_0$ $v_0$ $x_1$ $v_1$ ... $x_N$ $v_N$}
\spexamp{.table tab1 0 .1 1n .2 2n .4 3n .2 4n .1 5n 0\\
.table xgain 0 0 1 1 1 1.5 4 2\\
.table acvals ac 0 1.0 0, 1e3 .98 .03, ...\\
.table zz (0 table xgain 4 2)\\
.table tab1 0 1 .2 .5 .4 table txx .8 .5e-2}

The {\vt .table} line defines a tabulation of data points which can be
referenced from other lines in the SPICE file.  The data are listed in
sequence with respect to the ordinate $x_N$.  The elements are
separated by white space or commas, and may optionally be surrounded
by parentheses.  Generally, the table construct consists of many
lines, using the `+' or backslash line continuation mechanism.  When a
table is referenced, the data value returned is interpolated from the
values in the table.

The $x_i$ in the {\vt .table} line are values of the independent
variable (i.e., the variable given as an argument to the referencing
function).  The $v_i$ entries can be numbers, or a reference to
another table in the form
\begin{quote}
{\vt table} {\it subtab\_name}
\end{quote}
in which case that table will be referenced to resolve the data
point.

If the {\vt ac} keyword is given, the data numbers $v_i$ are
expected to be complex values, which are expressed as two values;
the real value followed by the imaginary value.  Any sub-tables
referenced must also have the {\vt ac} keyword given.  The {\vt ac}
tables provide data for frequency-domain analysis.  Without {\vt
ac}, all values are real, and the table is intended for use in dc or
transient analysis.

A non-ac table is referenced through a tran-function (see
\ref{tranfuncs}).  Tables with the {\vt ac} keyword given are
referenced through the {\vt ac} keyword in dependent and independent
sources (see \ref{indepsrc} and \ref{depsrc}).

Let {\vt x} be the input variable associated with the device
referencing a table.  The table is evaluated as follows:

\begin{tabular}{p{1in}p{3.5in}}
\vt x $<$ $x_0$ & $val = v_0(x_0)$\\
\vt $x_0 < {\vt x} < x_1$ & 
$val = v_0({\vt x})$ if $v_0$ is a table\newline
$val =$ interpolation of $v_0(x_0)$ and $v_1(x_1)$
if $v_0$ is a number\newline\newline
...\newline\\
\vt x $> x_N$ &
$val = v_N({\vt x})$ if $v_N$ is a table\newline
$val = v_N$  if $v_N$ a number\newline
$val = v_{N-1}(x_N)$ if $v_N$ is omitted\\
\end{tabular}

See the section \ref{examples} for sample input files which illustrate
the use of the {\vt .table} line.

%----------------------------------------------------
\subsection{{\vt .temp} Line}
\index{.temp line}
\spgen{.temp {\it temperature} [{\it temperatures} ...]}
\spexamp{.temp 25\\
.temp 0 25 50 75 100}

In some versions of SPICE, this card provides a list of temperatures,
and analysis will be performed at each temperature in the list.  The
temperature values are Celsius.

In {\WRspice}, the first temperature given will be used to construct a
dummy {\vt .options} line in the form
\begin{quote}
{\vt .options temp=}{\it value}
\end{quote}
This will appear before any other {\vt .options} line, so the given
temperature value will be overridden by a value provided by the user
in a {\vt .options} line.  The temperature can also be given with the
{\et temp} variable, set with the {\cb set} command or otherwise. 
Additional temperatures listed in the {\vt .temp} line are ignored. 

%------------------------------------------------------------------------------
\section{Parameters and Expressions}

% spInput.hlp:param 032320

%----------------------------------------------------
\subsection{Single-Quoted Expressions}
\index{single quoted expressions}
Text enclosed in single quotes (') will be evaluated as an expression
as the file is read and the string will be replaced by the result. 
This will occur throughout the SPICE text, with the exception of {\vt
.measure} lines, where single-quotes are traditionally (i.e., in
HSPICE) used as expression delimiters.

Single-quoted expressions outside of {\vt .subckt} blocks are expanded
before variable substitution and subcircuit expansion.  In this case,
since evaluation is performed before shell substitution, the
expression can not contain shell variables or other `{\vt \$}'
references.  Single-quoted expressions that appear within {\vt
.subckt} blocks are evaluated after variable substitution during
subcircuit expansion.  Thus, these expressions can contain shell '{\vt
\$}' constructs.

In general, single-quoted expressions can not contain vectors other
than those defined in the constants plot and ``{\vt temper}''.  If a
vector reference such as ``{\vt v(1)}'' is found in a single-quoted
expression being evaluated, the expression will be parameter expanded
as much as possible, but left in the form of an expression.  Thus, the
construct can appear only where an expression is expected by the
circuit parser, such as for the definitions of resistance and
capacitance for resistor and capacitor devices.

If the single-quoted expression appears to the left of an '=' sign, as
an assignment, no substitution is done.  In this case, the quotes are
ignored.

%----------------------------------------------------
\subsection{{\vt .param} Line}
\index{.param line}
\spgen{.param {\it name = value} [{\it name = value}] ...\\
  .param {\it func\/}({\it arg1\/}, ...) = {\it expression}}

\spexampo{.param p1 = 1.23 p2 = '2.5$*$p1'\\
 .param myabs(a) = 'a < 0 ? -a : a'}

This assigns the text {\it value} to the text token {\it name}.  The
{\it name} must start with a letter or underscore.  If the text string
{\it name}, delimited by space or one of {\vt ,)([]='"} but not with
`{\vt =}' to the right is found in the text, it is replaced by its
value. 

In 4.1.12 and later, node names are not parameter expanded by default. 
The boolean variable {\et pexnodes} if set will enable parameter
expansion of node names, for backward compatibility with files that
may have used this feature.  Also in 4.1.12, device and subcircuit
instance names are not parameter expanded, nor or subcircuit and model
names found in {\vt .subckt} and {\vt .model} lines.

The `{\vt \%}' concatenation character is recognized.  The
concatenation character is used to separate the token from the other
text:  for example {\vt RES\%K} allows {\vt RES} to be identified as a
token, and if {\vt RES} is `1' the substitution would yield `1K'.  The
{\it name} token must be surrounded by non-alphanumeric characters.

The concatenation character can be set to a different character with
the {\et var\_catchar} variable.  If this variable is set to a string
consisting of a single punctuation character, then that character
becomes the concatenation character.

Substitutions occur on a second pass, so the order of definition and
reference is not important (except when used in {\vt .if} or {\vt
.elif}, described below).  Substitutions are not performed in Verilog
blocks, but are performed everywhere else.  The {\vt .param} lines
always have global scope, meaning that they apply to the entire
circuit, whether or not they are located within {\vt .subckt} blocks.

Values can contain parameter references, i.e., nesting is accepted. 
       
It is also possible to define ``user defined'' functions using the
second form above.  This is similar to to the {\cb define} shell
function, but functions defined in this manner exist only transiently,
and will override a function of the same name and argument count
defined with the {\cb define} command. 

\subsubsection{Subcircuit Parameters}
 
Parameters can also be defined in subcircuit invocation ({\vt
.subckt}) and call lines.  When given in a {\vt .subckt} line, the
definition applies within that subcircuit, unless overridden.  When
given in a call line, the definition applies when expanding lines for
that instance only.

The default scoping of parameter substitution when there is more than
one definition for a name is global.  This means that the highest
level definition has precedence in a subcircuit hierarchy.  The
scoping rules are identical those of HSPICE.

\index{parhier variable}
The scoping rule set can be changed with the {\vt parhier} option. 
This can be set in a {\vt .options} line to one of two literal
keywords:  ``{\vt global}'' or ``{\vt local}''.  The global setting is
the default.  When ``{\vt local}'' is specified, the precedence order
is bottom-up, with the lowest level definition having precedence.

A parameter defined in a subcircuit instantiation line will override a
definition given in a {\vt .param} line in the subcircuit body, which
in turn will override a parameter definition provided in the {\vt
.subckt} line.  This sub-precedence is not affected by the {\vt
parhier} setting.

The scoping for function definitions follows that of normal
parameters, taking into account the {\vt parhier} setting. 
 
In general, these function definitions disappear from memory after
parameter expansion has been performed, however is some cases
``promoted macros'' will be created and saved with the current
circuit.  This occurs when a single-quoted expression references a
circuit variable, and also calls a function defined with the
parameters.  The function cannot be evaluated and is retained for
later evaluation (during analysis).  For this to succeed, the
referenced macros must be available as well, so these are ``promoted''
to a persistent database within the circuit data structure.  It is not
possible to undefine these functions, excapt by destroying or changing
the current circuit.  In the listing of functions provided by the {\cb
define} command without arguments, functions from the current circuit
are listed with an asterisk in the first column.

References to parameters outside of any {\vt .subckt} definition are
evaluated after variable expansion.  References within {\vt .subckt}
definitions are evaluated after variable substitution, during
subcircuit expansion.

The {\it value} must be a single token, or be enclosed by single or
double quotes.  If double quotes are used, they are stripped when the
substitution is applied.  Single quotes are retained in the
substitution, as single quotes have significance in delimiting an
expression.  Parameter substitution is performed whether or not the
substitution variable in part of a single or double quoted string.

Parameter expansion is applied to all lines of input, with an 
attempt made to be smart about what tokens are expanded and which
are not.  For example:
\begin{quote}{\vt
.subckt tline 1 2 3 4\\
T1 1 2 3 4 l=l c=c len=len\\
.ends tline}\\\\
This can be called as\\
{\vt xt1 1 0 2 0 l=1.5nh c=12ff len=1e-6}\\
Which expands to\\
{\vt T1.xt1 1 0 2 0 l=1.5nh c=12ff len=1e-6}
\end{quote}

This illustrates that in {\it param\/}={\it value} constructs, the
{\it value} is parameter expanded, not the {\it param\/}.  Thus, a
device parameter name keyword will not be expanded by a user-given
parameter of the same name.

Parameters can be accessed as vectors through the syntax ``{\vt @}{\it
paramname}''.  The value of the vector is the numerical value of the
parameter-expanded {\it value} string.  These vectors are read-only,
i.e., parameters can not be set through vectors.

\subsubsection{Pre-Defined Parameters}

The following parameter definitions are always automatically defined,
as if specified on a {\vt .param} line.  However, they are read-only,
and attempts to redefine them will silently fail.

\begin{description}
\item{\vt WRSPICE\_BATCH}\\
This parameter is set to 1 if {\WRspice} is running in batch mode, 0
otherwise.

\item{\vt WRSPICE\_PROGRAM}\\
The value of this parameter is set to 1.  This enables users to
include {\WRspice}-specific input in SPICE files, which will be
ignored by other simulators (and vice-versa).  The following lines
will accomplish this:

\begin{quote}
{\vt .param WRSPICE\_PROGRAM=0}\\
{\vt .if WRSPICE\_PROGRAM=1}\\
({\it input lines specific for WRspice\/})\\
{\vt .else}\\
({\it input lines specific to another simulator\/})\\
{\vt .endif}\\
\end{quote}

The first ({\vt .param}) line would be silently ignored in {\WRspice},
so that the ``({\it input lines specific for WRspice\/})'' will be
read.  In another simulator, the parameter definition will set {\vt
WRSPICE\_PROGRAM} to zero, so that the ``({\it input lines specific to
another simulator\/})'' would be read instead.

\item{\vt WRSPICE\_RELEASE}\\
The parameter {\vt WRSPICE\_RELEASE} is predefined with the release
code number.  The release code number is a five digit integer {\it
xyzz\/}0, corresponding to release {\it x.y.z}.  The {\it x} and {\it
y} fields are one digit, {\it z} is two digits, 0 padded.  The
trailing 0 is a historical anachronism.  For example, release 3.1.15
has release code number 32150.  This parameter is read-only, and
attempts to change its value in a {\vt .param} line or otherwise are
silently ignored.
\end{description}

%----------------------------------------------------
\subsection{{\vt .if}, {\vt .elif}, {\vt .else}, and {\vt .endif} Lines}
\index{.if line}
\index{.elif line}
\index{.else line}
\index{.endif line}
\spgen{.if {\it expression} [ = {\it expression\/}]}
\spgen{.elif {\it expression} [ = {\it expression\/}]}
\spgen{.else}
\spgen{.endif}
\spexampo{
    SPICE deck title line\\
    ...\\
    .param use\_new\_mod = 8\\
    ...\\
    .if use\_new\_mod = 8\\
    .model m1 nmos(level=8 ...\\
    .elif use\_new\_mod = 9\\
    .model m1 nmos(level=9 ...\\
    .elif use\_new\_mod\\
    .model m1 nmos(level=10 ...\\
    .else\\
    .model m1 nmos(level = 3 ...\\
    .endif}

For compatibility with other simulators, the keyword ``{\vt .elseif}''
is accepted as an alias for ``{\vt .elif}''.

The {\WRspice} input file syntax supports conditional blocks, through
use of these directives.  The {\it expression} can involve constants,
parameter names from a {\vt .param} line included in the file, or
vectors and shell variables defined {\it before} the file is read.  It
does not understand variables implicitly set by inclusion in the {\vt
.options} line, or parameters set in {\vt .subckt} lines or
references.  The scope for these constructs is always global, meaning
that they apply to lines of text in the file without regard to {\vt
.subckt} block boundaries.

The construct {\vt def}({\it paramname\/}) can be used in the {\it
expression\/}, where it is replaced by 1 or 0 if {\it paramname} is
defined or not.  Thus, one can define parameters that have not been
previously defined with
\begin{quote}\vt
.if !def(myparam)\\ 
.param myparam=2\\
.endif
\end{quote}

If the single {\it expression} is nonzero, or the two expressions
yield the same result, the lines following {\vt .if} up to the
matching {\vt .elif}, {\vt .else} or {\vt .endif} are read, and if an
{\vt .else} block follows, those lines to the matching {\vt .endif}
are discarded.  If the single {\it expression} if zero or the two
expressions do not match, the lines following {\vt .if} to the
matching {\vt .elif}, {\vt .else} or {\vt .endif} are discarded, and
if a {\vt .else} line follows, the lines following {\vt .else} to {\vt
.endif} are retained.  These blocks can be nested.  The action is
similar to the C preprocessor.

This filtering is performed early in the parsing of the file, so that
the {\vt .if}, etc.  lines can enclose script lines, Verilog blocks,
etc., and not simply circuit lines.  The lines not in scope are never
saved in memory.

The predefined read-only {\vt WRSPICE\_RELEASE} parameter can be used
in conjunction with the {\vt .if} conditionals to select
{\WRspice}-specific lines in input files.

For example:
\begin{quote}\vt
.param WRSPICE\_RELEASE=0  \$ This is ignored by WRspice\\
.if WRSPICE\_RELEASE\\
({\it WRspice-specific lines\/})\\
.else\\
({\vt lines for HSPICE or whatever\/})\\
.endif
\end{quote}


%------------------------------------------------------------------------------
\section{Subcircuits}
\index{subcircuits}

% spInput.hlp:subckt 110111

A subcircuit that consists of {\WRspice} elements can be defined and
referenced in a fashion similar to device models.  The subcircuit is
defined in the input file by a grouping of element lines; the program
then automatically inserts the group of elements wherever the
subcircuit is referenced.  There is no limit on the size or complexity
of subcircuits, and subcircuits may contain other subcircuits.  An
example of subcircuit usage is given in \ref{examples}.

%----------------------------------------------------
\subsection{{\vt .subckt} Line}
\index{.subckt line}
\index{subcircuit declaration}
\spgen{.subckt {\it subnam n1} [{\it n2} ...] [{\it param1=val1
    param2=val2} ...]}
\spexamp{.subckt opamp 1 2 3 4\\
.subckt stage1 3 10 2 resis=2k cap=1nf}

The keyword ``{\vt .macro}'' is equivalent to ``{\vt .subckt}''.  The
``{\vt .subckt}'' keyword is actually a default, and this keyword can
be reset through setting the {\et substart} variable.  The {\vt
.macro} variable applies in any case.

A subcircuit definition begins with a {\vt .subckt} line.  The
{\it subnam\/} is the subcircuit name, and {\it n1\/}, {\it n2\/},
...  are the external nodes, which cannot be zero.  The group of
element lines which immediately follow the {\vt .subckt} line define
the subcircuit.  The last line in a subcircuit definition is the {\vt
.ends} line (see below).  Control lines should not appear within a
subcircuit definition, however subcircuit definitions may contain
anything else, including other subcircuit definitions, device models,
and subcircuit calls (see below).  Note that any device models or
subcircuit definitions included as part of a subcircuit definition are
strictly local (i.e., such models and definitions are not known
outside the subcircuit definition).  Also, any element nodes not
included on the {\vt .subckt} line or in {\vt .global} lines are
strictly local, with the exception of 0 (ground) which is always
global.

The subcircuit declaration line can contain an optional list of {\it
param\/}={\it value} pairs.  The {\it params} are tokens which must
start with a letter or underscore, which can appear in the subcircuit
lines.  These are not shell variables, so there is no `{\vt \$}' or
other punctuation, but the `{\vt \%}' concatenation character is
recognized.  The concatenation character is used to separate the token
from the other text:  for example {\vt RES\%K} allows {\vt RES} to be
identified as a token, and if {\vt RES} is `1' the substitution would
yield `1K'.  The {\it param} token must be surrounded by
non-alphanumeric characters.

The concatenation character can be set to a different character with
the {\et var\_catchar} variable.  If this variable is set to a string
consisting of a single punctuation character, then that character
becomes the concatenation character.

{\WRspice} can handle duplicate formal node args in {\vt .subckt}
lines.  It does so by assigning a new node to one of the duplicates,
then inserting a voltage source between the two nodes, which is added
to the subcircuit text.  This mainly solves a problem related to files
generated by {\Xic}.  If two or more subcircuit terminals are attached
to the same wire net, the resulting {\it .subckt} line will have
duplicate nodes.  In the limiting case where a subcircuit consists
only of a wire with two connections, the subcircuit would in addition
be empty.

For example, the definition
\begin{quote}
{\vt .subckt xxx 1 1\\
 .ends}
\end{quote}

is converted to
\begin{quote}
{\vt .subckt xxx 1 \_\#0\\
 v\_xxx\_0 1 \_\#0\\
 .ends}
\end{quote}
during subcircuit expansion, which avoids an empty subcircuit and
has the intended effect of instances shorting the two terminals
together.

%-------------------
\subsubsection{Subcircuit Expansion}
\label{subexpand}
\index{subcircuit expansion}

When processing circuit input that contains subcircuits, {\WRspice}
will perform ``subcircuit expansion'' whereby subcircuit calls are
replaced recursively with the subcircuit body text, with the device
and node names translated so as to make them unique in the overall
circuit.  This ``flat'' representation, which can be seen with the
{\cb listing e} command, is the form that is actually parsed to
generate the internal circuit structure used in simulation.

Although this occurs ``behind the scenes'', if a user needs to
reference nodes or devices within subcircuits, for example in a {\cb
print} or {\cb plot} command after analysis, the user will need to
know the details of the name mapping employed.  The same applies when
the user is preparing SPICE input, if, for example, the user wishes to
use the {\vt .save} keyword with a subcircuit node.  In this case, the
SPICE deck will fail to work as intended unless the mapping algorithm
assumed by the user is actually employed by the simulator.

{\WRspice} releases prior to 3.2.15 used the SPICE3 algorithm for
generating the new node and device names.  Subsequent releases have a
new, simpler algorithm as the default, but support for the old
algorithm is retained.  The field separation character, used when
creating new names, has changed twice in {\WRspice} evolution.  Thus,
there is a potential compatibility issue with legacy {\WRspice} input
files that explicitly reference subcircuit nodes, and newer {\WRspice}
releases.

There are two variables which set the subcircuit mapping mode and
concatenation character.

\begin{description}
\index{subc\_catchar variable}
\item{\et subc\_catchar}\\
This can be set to a string consisting of a single punctuation
character, which will be used as the field separation character in
names generated in subcircuit expansion.  It should be a character
that is not likely to confuse the expression parser.  This requirement
is rather ambiguous, but basically means that math operators, comma,
semicolon, and probably others should be avoided.

In release 3.2.15 and later the default is `{\vt .}' (period), which
is also used in HSPICE, and provides nice-looking listings.

In releases 3.2.5 -- 3.2.14, the default was `{\vt \_}' (underscore).

In release 3.2.4 and earlier, and in SPICE3, the concatenation
character was `{\vt :}' (colon).

\index{subc\_catmode variable}
\item{\et subc\_catmode}\\
This string variable can be set to one of the keywords ``{\vt
wrspice}'' or ``{\vt spice3}''.  It sets the encoding mode for
subcircuit node and device names.  In 3.2.15 and later, the ``{\vt
wrspice}'' mode is the default.  In earlier releases, only the ``{\vt
spice3}'' mode was available.
\end{description}

The format of the subcircuit node names depends on the algorithm, so
SPICE input that explicitly references subcircuit node names
implicitly assuming a certain mapping algorithm will require either
changes to the node names, or specification of the matching algorithm
and concatenation character.

These variables can be set from a {\vt .options} line in SPICE input,
so that the easiest way to ``fix'' an old file is to add a {\vt
.options} line.

For example, suppose that you run an old deck, and get warnings like
``{\vt no such vector 0:67}''.  From the descriptions below, one can
recognize that 1) the SPICE3 mode is being used, which will always be
true for old decks, and 2) the concatenation character is `{\vt :}'. 
Thus, adding the following line to the file will fix the problem.

\begin{quote}\vt
.options subc\_catchar=: subc\_catmode=spice3
\end{quote}

When running from {\Xic}, there should not be compatibility issues, as
{\Xic} will automatically recognize the capabilities of the connected
{\WRspice} and compensate accordingly -- as long as the hypertext
facility is used to define node names.  This is true when
point-and-click is used to generate node names.  However, subcircuit
node names that for some reason were entered by hand will need to be
updated, or a {\vt .options} line added as a spice-text label.

\subsubsection{{\vt wrspice} Mode}

As an example, suppose we have a device line
\begin{quote}\vt
C126 2 4 50fF
\end{quote}
in a subcircuit which is instantiated as a subcircuit instance {\vt
Xgate}, which itself is instantiated at the top level in a subcircuit
instance {\vt Xadder}.  After applying the {\vt wrspice} algorithm, this
line becomes
\begin{quote}\vt
C126.Xgate.Xadder 2.Xgate.Xadder 4.Xgate.Xadder 50fF
\end{quote}
assuming the use of `{\vt .}' as the concatenation character.  Note
the straightforwardness of this approach:  one merely starts with the
given name (device or node) and appends a concatenation character and
subcircuit instance name, walking up the hierarchy.  The `{\vt x}' or
`{\vt X}' characters of the instance names are retained.

In addition, if a device model is defined in a subcircuit, the model
name is mapped as follows.  Suppose that the subcircuit instantiated
as {\vt Xgate} contained a {\vt .model} line like
\begin{quote}\vt
.model foo nmos(...)
\end{quote}

The model is only accessible in instances of this subcircuit (and any
sub-subcircuits), with the name mapped to (for example)
\begin{quote}\vt
.model foo.Xgate.Xadder nmos(...)
\end{quote}

Thus models use exactly the same naming convention.  Note that models
are generated per-instance rather than per-subcircuit.  The reason is
that if the subcircuit is parameterized, the model in each instance
may be different, if different parameters are provided to the
instances, and model text uses the parameters.

\subsubsection{{\vt spice3} Mode}

The SPICE3 encoding is a bit more obscure.  Suppose that we have the
same example hierarchy as above.  The line maps to
\begin{quote}\vt
C.adder.gate.126 adder.gate.2 adder.gate.4 50fF
\end{quote}

Again, this assumes `{\vt .}' as the concatenation character, which is
a bad choice for this mapping mode as we shall see.  The {\vt spice3}
mode was historically used with `{\vt :}' or `{\vt \_}' as the
concatenation character.

For device names, we start with the first character, add a
concatenation character, then the top instance name with the `{\vt X}'
stripped and continue down the hierarchy.  Finally, we add a
concatenation character and the remainder of the original device name.

For nodes, we start with the top-level instance name with the `{\vt
X}' stripped, walk down the hierarchy adding contenation characters
and sub-instance names (also with the `{\vt X}' stripped), and finally
append a concatenation character and the original node name.

For models defined in subcircuits, in the example above, the mapping
is
\begin{quote}\vt
.model adder.gate.foo nmos(...)
\end{quote}

What if instead of {\vt Xgate} and {\vt Xadder}, the instance names
were {\vt X0} and {\vt X1}?  The expansion becomes
\begin{quote}\vt
C.1.0.126 1.0.2 1.0.4 50fF
\end{quote}

This is very cumbersome to keep straight.  Worse, if the hierarchy is
only one-deep, we could get node names like ``{\vt 0.1}'', ``{\vt
1.2}'', etc.  which are in some cases impossible for the parser to
distinguish from a floating point value.  Using a different
concatenation character solves this problem, but the names are still
rather opaque.

%----------------------------------------------------
\subsection{{\vt .ends} Line}
\index{.ends line}
\spgen{.ends [{\it subnam\/}]}
\spexampo{.ends opamp}

The keyword ``{\vt .eom}'' is equivalent to ``{\vt .ends}''.  The
``{\vt .ends}'' is actually a default and the keyword can be changed
by setting the {\et subend} variable.  The {\vt .eom} keyword applies
in any case.

This line must be the last one for any subcircuit definition.  The
subcircuit name, if included, indicates which subcircuit
definition is being terminated; if omitted, all subcircuits being
defined are terminated.  The name is needed only when nested
subcircuit definitions are being made.

%----------------------------------------------------
\subsection{Subcircuit Calls}
\index{subcircuit call}
\spgen{x{\it name n1} [{\it n2 n3} ...] {\it subnam\/}
[{\it param1=val1 param2=val2} ...]}
\spexampo{x1 2 4 17 3 1 multi}

Subcircuits are used in {\WRspice} by specifying pseudo-elements
beginning with the letter `{\vt x}' or `{\vt X}', followed by the
circuit nodes to be used in expanding the subcircuit.

When a circuit is parsed, all devices and local nodes in subcircuits
are renamed as
\begin{quote}
{\it devicetype\/}{\bf [sep]}{\it subcktname\/}{\bf [sep]}{\it devicename\/},
\end{quote}
where {\bf [sep]} is a separation character. 
In SPICE3 and {\WRspice} prior to release 3.2.4, this was the colon
(`:') character.  However, this choice can lead to conflicts and
parser trouble due to the use of the colon in the ternary conditional
operator {\it a\/}{\vt ?}{\it b\/}{\vt :}{\it c\/}.  In release 3.2.4,
the separation character was changed to the underscore (`{\vt \_}').

The character employed can be set from the shell with the shell
variable {\et subc\_catchar}.  If this variable is set to a string
consisting of a single punctuation character, then this character
becomes the {\bf [sep]} character. 

Nested subcircuit instances will have multiple {\bf [sep]}-separated
qualifiers.

The names and default values of the {\it params} are specified in the
{\vt .subckt} line.  During subcircuit expansion, the {\it param}
tokens are replaced by their corresponding {\it value} tokens in the
text.  If a list of {\it params} is given in the subcircuit
instantiation line, those values will supersede the defaults in that
subcircuit instance, and parameters set in {\vt .param} lines.

\spexampo{
    .subckt resistor 1 2 resis=1k\\
    r1 1 2 resis\\
    .ends\\
\\
    x1 3 4 resistor resis = 500\\
    x2 5 6 resistor\\
    x3 7 8 resistor resis=2k}

%----------------------------------------------------
\subsection{Subcircuit/Model Cache}
\index{subcircuit/model cache}

\spgen{
    .cache {\it name\/}\\
    {\it Lines of SPICE input...}\\
    .endcache}

\spexampo{
    .cache block1\\
    .include /users/models/some\_big\_library\\
    .endcache}

The ``models'' provided with foundry design kits (for example) have
become quite complex, to the point where loading these files into
{\WRspice} can take appreciable time.  These files often encapsulate
device calls into subcuits, and use large numbers of parameter
definitions that must be processed into internal tables.

This overhead is annoying when simulating circuits, but can become a
real problem when doing repetitive simulations such as for Monte Carlo
analysis or when under control of a looping script.  The caching
feature enables one to load these definitions once only, on the first
pass.  Subsequent runs will reuse the internal representations, which
can avoid most of the overhead.

The ``{\vt .cache}'' and ``{\vt .endcache}'' SPICE file keywords are
used to identify lines of an input deck which will be cached.  This
syntax is non-standard and available only in {\WRspice}.

The {\it name} is any short alpha-numeric name token, used to identify
the cache block created.  The cached representation of the enclosed
lines is saved in {\WRspice} memory under this name.

Presently, there can be only one {\vt .cache} block per circuit deck. 
The first time the {\it name} is seen, the enclosed lines are
processed normally but internal representations are saved. 
Subsequently, the enclosed lines are skipped.  The skipping occurs
very early in the sourcing operation, before {\vt .include} and
similar lines are read.  So, for the example, the access to {\vt
some\_big\_library} is skipped entirely in subsequent runs.

If a different SPICE input file is sourced, and this has a {\vt
.cache} block with the same {\it name} as the first, the cached
parameters from the first file will be used in the second file.  The
internal representation of the cache block has no attachment to any
particular input file.

The {\it Lines of SPICE input...} which can appear between {\vt
.cache} and {\vt .endcache} can be, after {\vt .include}/{\vt .lib}
expansion:

\begin{enumerate}
\item{Subcircuit definitions, which must include all lines of the
    definition including the {\vt .subckt} or {\vt .macro} line and
    corresponding {\vt .ends} or {\vt .eom} line.}
\item{Model definitions, starting with {\vt .model}.}
\item{Parameter definitions, starting with {\vt .param}.}
\item{Comment lines.}
\end{enumerate}

The block can contain any of the {\vt .include}/{\vt .lib} family of
lines, but after these lines are expanded, the resulting text should
contain only the forms listed above.  Anything else that appears in
the cache block will likely cause an error, as it will be ``missing''.

The parameters from {\vt .param} lines saved in the cache will
override parameters of the same name defined elsewhere in the circuit
file.

The subcircuit/model cache can be manipulated with the {\WRspice}
{\cb cache} command.


%------------------------------------------------------------------------------
\section{Analysis Specification}

% spAnalysis.hlp:analyses 060219

\index{dc analysis, chained}
{\WRspice} provides the analysis capabilities tabulated below. 
Monte Carlo and operating range analysis (described in Chpt. 
\ref{oprange}) require a special input file format, while other types
of analysis can be specified in a standard input deck.

Analyses will pause if {\WRspice} receives an interrupt signal, i.e.,
the user types {\kb Ctrl-C} while {\WRspice} has the keyboard focus. 
The {\cb resume} command can be used to resume the analysis.

\index{maxdata variable}
By default, the maximum size of the data produced by an analysis run
is limited to 256Mb.  This can be changed by setting the variable {\et
maxdata} to the desired value in Kb, using the {\cb set} command or
the {\cb Simulation Options} tool from the {\cb Tools} menu of the
{\cb Tool Control} window.  In transient analysis, if the {\et
steptype} is not set to ``{\vt nousertp}", the run will abort at the
beginning if the memory would exceed the limit.  Otherwise, the run
will end when the limit is reached.

The table below lists the basic analysis types and input file keyword.

\begin{tabular}{|l|l|}\hline
\vt .ac & AC Small-Signal Analysis\\ \hline
\vt .dc & DC Analysis\\ \hline
\vt .disto & Small-Signal Distortion Analysis\\ \hline
\vt .noise & Small-Signal Noise Analysis\\ \hline
\vt .op & Operating Point\\ \hline
\vt .pz & Pole-Zero Analysis\\ \hline
\vt .sens & DC or Small-Signal AC Sensitivity Analysis\\ \hline
\vt .tf & DC or Small-Signal AC Transfer Function Analysis\\ \hline
\vt .tran & Transient Analysis\\ \hline
\end{tabular}

An operating point analysis is performed implicitly before other types
of analysis, with the exception of transient analysis when the {\vt
uic} keyword is given.  This solves for the initial dc operating point
of the circuit.  The circuit is linearized at this point for AC/small
signal analysis (including pole-zero, transfer function, and noise
analysis).  It is the starting point for dc and transient analysis.

%----------------------------------------------------
\subsection{Chained Sweep Analysis}
\index{chained analysis}
\index{sweep analysis}

% spAnalysis.hlp:multidc 051016
\newcommand{\swspec}{{{\it pstr1 start1\/} [{\it stop1\/} [{\it incr1\/}]]
 [{\it pstr2 start2\/} [{\it stop2\/} [{\it incr2\/}]]]}}

{\WRspice} has a swept analysis feature.  This allows ac, noise,
transfer function, sensitivity, and transient analyses to have an
additional one or two dimensional sweep specification, resulting in
the analysis being performed at each parameter value, producing a
multidimensional output plot.

The syntax is
\begin{quote}
{\it analysis} {\vt dc}$|${\vt sweep} \swspec
\end{quote}

The initiating keyword can be ``{\vt dc}'' or ``{\vt sweep}'', and is
followed by one or two parameter specifiers and ranges.  This is the
same syntax as accepted in the {\WRspice} {\vt .dc} line, which is an
extension of the traditional DC source sweep.  In {\WRspice}, any
circuit parameter can be swept.  This is far more powerful than the
original SPICE dc sweep, which only allowed sweeping of source
outputs.

For example, a regular SPICE dc sweep would have a form like:
\spexampo{.ac dec 10 1Hz 1Khz dc v1 0 2 .1 v2 4.5 5.5 .25}

\index{vectors, dimension}
This will perform an ac analysis with the dc sources {\vt v1} and {\vt
v2} stepped through the respective ranges.  The resulting output
vectors will have dimensions [5,21,61], as can be seen with the {\et
display} command interactively.  This represents 61 points of
frequency data at 21 {\vt v1} values at 5 {\vt v2} values.  Typing
``{\vt plot v(1)}'' (for example) would plot all 21*5 analyses on the
same scale (you probably don't want to do this).  One can also type
(as examples) ``{\vt plot v(1)[1]}'' to plot the results for {\vt v2}
= 4.75, or ``{\vt plot v(1)[0][1]}'' for {\vt v2} = 4.5, {\vt v1} =
.1, etc.  Range specifications also work, for example ``{\vt plot
v(1)[2][0,2]}'' plots the values for {\vt v2} = 5.0, {\vt v1} = 0.0,
0.1, 0.2.

{\WRspice} also allows forms like
\spexampo{.ac dec 10 1Hz 1Khz dc R1[res] 800 1200 100 R5[res] 10 20 1}
This will perform the ac analysis as the values of two resistors
are swept.

Warning:  The memory space required to hold the plot data can grow
quite large, so be reasonable.

Multi-threading (see \ref{threads}) will be used for chained analysis
if the {\et loopthrds} variable is set to a positive value.  This can
parallelize the runs on computers with multiple cores or CPUs,
speeding evaluation.

%----------------------------------------------------
\subsection{{\vt .ac} Line}
\index{.ac line}
\index{ac analysis}
\index{analysis!ac}
\label{acline}

% spAnalysis.hlp:.ac 060219

The ac small-signal portion of {\WRspice} computes the ac output
variables as a function of frequency.  The program first computes the
dc operating point of the circuit and determines linearized,
small-signal models for all of the nonlinear devices in the circuit. 
The resultant linear circuit is then analyzed over a user-specified
range of frequencies.  The desired output of an ac small-signal
analysis is usually a transfer function (voltage gain, transimpedance,
etc).  If the circuit has only one ac input, it is convenient to set
that input to unity and zero phase, so that output variables have the
same value as the transfer function of the output variable with
respect to the input.

\spgen{.ac dec|oct|lin {\it np fstart fstop\/} [dc$|$sweep {\it args\/}]}
\spexamp{.ac dec 10 1 10k\\
.ac dec 10 1k 100meg\\
.ac lin 100 1 100hz dc vcc 10 15 5\\
.ac dec 10 1meg 1g dc vdd 5 7.7 .25}

The keyword {\vt dec} specifies decade variation, with {\it np\/} the
number of points per decade.  The keyword {\vt oct} specifies octave
variation, with {\it np\/} the number of points per octave, and {\vt
lin} specifies linear variation, with {\it np\/} the number of points. 
The two parameters {\it fstart\/} (the starting frequency), and {\it
fstop\/} (the final frequency) complete the basic analysis
specification.  If this line is included in the circuit file,
{\WRspice} will perform an ac analysis of the circuit over the
specified frequency range.  Note that in order for this analysis to be
meaningful, at least one voltage or current source must have been
specified with an {\vt ac} value.

There is a subtlety when using {\vt dec} with {\it fstop\/}/{\it
fstart} less than 10.  {\WRspice} will adjust the frequency delta to
hit the final value, if the frequency ratio is integral.  This is very
appropriate when {\it fstop\/}/{\it fstart} is a power of two and {\it
np} is 10.  The table shows the frequency multiplication factors
without and with correction.  Without correction, the frequency
multiplier is the tenth root of 10.  The corrected multiplier is the
ninth root of 8.  With correction, the binary powers are hit exactly.

\begin{quote}
\begin{tabular}{ll}
\bf Uncorrected & \bf Binary Correction\\
1.000000 & 1.000000\\
1.258925 & 1.259921\\
1.584893 & 1.587401\\
1.995262 & 2.000000\\
2.511886 & 2.519842\\
3.162278 & 3.174802\\
3.981072 & 4.000000\\
5.011872 & 5.039684\\
6.309573 & 6.349604\\
7.943282 & 8.000000\\
10.000000 & 10.079368\\
\end{tabular}
\end{quote}

The optional dc sweep is a dc analysis specification which will cause
the ac analysis to be performed at each point of the dc sweep.  The
small-signal parameters are reevaluated at every sweep point, and the
output vectors will be multidimensional.

In interactive mode, the {\cb ac} command, which takes the same
arguments as the {\vt .ac} line, can be used to initiate ac analysis.

AC analysis is not available if Josephson junctions are included in the
circuit.

%----------------------------------------------------
\subsection{{\vt .dc} Line}
\index{.dc line}
\index{dc analysis}
\index{analysis!dc}
\label{dcline}

% spAnalysis.hlp:.dc 120115

The dc analysis portion of {\WRspice} determines the dc operating
point of the circuit with inductors shorted and capacitors opened. 
The dc analysis is used to generate dc transfer curves:  a specified
device parameter (commonly a voltage or current source output) is
stepped over a user-specified range and the dc output variables are
stored for each sequential parameter value.

\spgen{.dc \swspec}
\spexamp{.dc vin 0.25 5.0 0.25\\
.dc vds 0 10 .5 vgs 0 5 1\\
.dc vce 0 10 .25 ib 0 10u 1u\\
.dc vdd 5 6\\
.dc r1 1k 2k 100\\
.dc d1[temp] 0 50 5}

The {\vt .dc} line defines the dc sweep source and sweep limits.  The
variation may be in one or two dimensions, depending upon whether the
second block is provided.

In traditional Berkeley SPICE, the {\it pstr1} and {\it pstr2} are the
names of voltage or current sources in the circuit, and the specified
range applies to the output from that source.  In {\WRspice} the {\it
pstr1} and {\it pstr2} can specify arbitrary device parameters which
will be varied through the given range.  The complete syntax is

\begin{quote}
{\it devname\/}{\vt [}{\it param\/}{\vt ]}
\end{quote}

The {\it devname} is the name of a device in the circuit.  The square
brackets are literal, and enclose the name of a parameter of the
device.  Device parameter names are defined in the device model, and
can be listed with the {\cb show} command.

If the {\it devname} is that of a source device, or a resistor,
capacitor, or inductor, the square brackets and parameter name can be
omitted.  In this case, the parameter will default to the source
output, or resistance, capacitance, or inductance of the respective
device.  Other device types require specification of a parameter in
square brackets.

The {\it start\/}, {\it stop\/}, and {\it incr} parameters are the
starting, final, and incrementing values respectively.  If the {\it
incr} parameter is not supplied, analysis is performed at {\it start}
and {\it stop\/}.  If in addition the {\it stop} parameter is not
given, analysis is performed at {\it start\/}, i.e., the level is
fixed.  A parameter can be omitted only if all parameters to the right
are also omitted.

A second parameter ({\it pstr2\/}) may optionally be specified with
associated sweep specification.  In this case, the first parameter
will be swept over its range for each value of the second parameter. 
This option can be useful for obtaining semiconductor device output
characteristics.

The first example will cause the value of the voltage source {\vt vin}
to be swept from 0.25 volts to 5.0 volts in increments of 0.25 volts.

In stand-alone dc sweep analysis, the circuit operating point is
computed for each parameter value.  In {\WRspice}, other types of
analysis (ac, noise, transfer function, sensitivity, and transient)
can be chained to a dc analysis specification.  In this case, the
requested analysis is performed at each successive operating point, as
specified by the dc part of the analysis specification.  The resulting
circuit variables are saved as multidimensional vectors, which can
subsequently be saved in a rawfile or plotted (together or as
individual traces).

In intetactive mode, the {\cb dc} command, which takes the same
arguments as the {\vt .dc} line, can be used to initiate dc analysis.

If the {\et loopthrds} variable is set to a value larger than zero,
the calculations will use multi-threading so that if multiple CPUs are
available, work can be done in parallel, saving time.

If Josephson junctions are present in the circuit, they will be taken
as shorted (actually, a resistance of 1uV/Ic) during dc analysis. 
It is in general not possible to perform this type of analysis on
Josephson junctions.  The approach taken here may be useful when
working with hybrid semiconductor/superconductor circuits, but in no
case should one expect dc analysis of Josephson circuits to ``work''. 
Transient analysis, which takes into account the past history of the
Josephson excitation, is required for a complete simulation.

%----------------------------------------------------
\subsection{{\vt .disto} Line}
\index{.disto line}
\index{distortion analysis}
\index{analysis!distortion}
\label{distoline}

% spAnalysis.hlp:.disto 041811

The distortion analysis portion of {\WRspice} computes steady-state
harmonic and intermodulation products for small input signal
magnitudes.  If signals of a single frequency are specified as the
input to the circuit, the complex values of the second and third
harmonics are determined at every point in the circuit.  If there are
signals of two frequencies input to the circuit, the analysis finds
the complex values of the circuit variables at the sum and difference
of the input frequencies, and at the difference of the smaller
frequency from the second harmonic of the larger frequency.

Distortion analysis is supported in {\WRspice} only through
residual incorporation from code imported from Berkeley SPICE3.  This
code is particularly complex, poorly documented, and ugly.  Distortion
analysis has not been tested, and may not work.

Distortion analysis is included for the following nonlinear devices: 
diodes, bipolar transistors, JFETs, MOSFETs (levels 1, 2, 3 and BSIM1)
and MESFETS.  All linear devices are automatically supported by
distortion analysis.  If there are switches present in the circuit,
the analysis will continue to be accurate provided the switches do not
change state under the small excitations used for distortion
calculations.

\spgen{.disto dec|oct|lin {\it np fstart fstop\/} [{\it f2overf1\/}]
 [dc {\it dc\_args}]}
\spexamp{.disto dec 10 1khz 100mhz\\
.disto dec 10 1khz 100mhz 0.9}

A multi-dimensional Volterra series analysis is performed using a
multi-dimensional Taylor series to represent the nonlinearities at the
operating point.  Terms of up to third order are used in the series
expansions.

If the optional parameter {\it f2overf1\/} is not specified, a
harmonic analysis is performed --- i.e., distortion is analyzed in the
circuit using only a single input frequency {\it f1}, which is swept
as specified by arguments of the {\vt .disto} line exactly as in an
{\vt .ac} line.  Inputs at this frequency may be present at more than
one input source, and their magnitudes and phases are specified by the
arguments of the {\vt distof1} keyword in the input file lines for the
input sources.  The arguments of the {\vt distof2} keyword are not
relevant in this case.  The analysis produces information about the ac
values of all node voltages and branch currents at the harmonic
frequencies $2f1$ and $3f1$, vs.  the input frequency {\it f1} as it
is swept.  A value of 1 (as a complex distortion output) signifies
$cos(2\pi(2f1)t)$ at $2f1$ and $cos(2\pi(3f1)t)$ at $3f1$, using the
convention that 1 at the input fundamental frequency is equivalent to
$cos(2\pi\/f1\/t)$.

The distortion component desired ($2f1$ or $3f1$) can be selected
using commands in {\WRspice}, and then printed or plotted.  Normally,
one is interested primarily in the magnitude of the harmonic
components, so the magnitude of the ac distortion value is considered. 
It should be noted that these are the ac values of the actual harmonic
components, and are not equal to HD2 and HD3.  To obtain HD2 and HD3,
one must divide by the corresponding ac values at {\it f1}, obtained
from an {\vt .ac} line.  This division can be done using {\WRspice}
commands.

If the optional {\it f2overf1} parameter is specified, it should be a
real number between (and not equal to) 0.0 and 1.0; in this case, a
spectral analysis is performed.  The circuit is considered with
sinusoidal inputs at two different frequencies {\it f1} and {\it f2}. 
Frequency {\it f1} is swept according to the {\vt .disto} line options
exactly as for the {\vt .ac} card.  Frequency {\it f2} is kept fixed
at a single frequency as {\it f1} sweeps --- the value at which it is
kept fixed is equal to {\it f2overf1*fstart\/}.  Each voltage and
current source in the circuit may potentially have two (superimposed)
sinusoidal inputs for distortion, at the frequencies {\it f1} and {\it
f2}.  The magnitude and phase of the {\it f1} component are specified
by the arguments of the {\vt distof1} keyword in the source's input
line, as described in \ref{indepsrc}; the magnitude and phase of the
{\it f2} component are specified by the arguments of the {\vt distof2}
keyword.  The analysis produces plots of all node voltages/branch
currents at the intermodulation product frequencies $f1+f2$, $f1-f2$,
and $(2f1)-f2$, vs the swept frequency {\it f1}.  The IM product of
interest may be selected using the {\cb setplot} command, and
displayed with the {\cb print} and {\cb plot} commands.  As in the
harmonic analysis case, the results are the actual ac voltages and
currents at the intermodulation frequencies, and need to be normalized
with respect to {\vt .ac} values to obtain the IM parameters.

If the {\vt distof1} or {\tt distof2} keywords are missing from the
description of a voltage or current source, then that source is
assumed to have no input at the corresponding frequency.  The default
values of the magnitude and phase are 1.0 and 0.0 respectively.  The
phase should be specified in degrees.

It should be noted that the number {\it f2overf1\/} should ideally be
an irrational number, and that since this is not possible in practice,
efforts should be made to keep the denominator in its fractional
representation as large as possible, certainly above 3, for accurate
results.  If {\it f2overf1\/} is represented as a fraction $A/B$,
where $A$ and $B$ are integers with no common factors, $B$ should be
as large as possible.  Note that $A < B$ because {\it f2overf1\/} is
constrained to be {\vt <} 1).  To illustrate why, consider the cases
where {\it f2overf1\/} is 49/100 and 1/2.  In a spectral analysis, the
outputs produced are at $f1+f2$, $f1-f2$ and $2f1-f2$.  In the latter
case, $f1-f2 = f2$, so the result at the $f1-f2$ component is
erroneous because there is the strong fundamental $f2$ component at
the same frequency.  Also, $f1+f2 = 2f1-f2$ in the latter case, and
each result is erroneous individually.  This problem is not seen in
the case where $f2overf1 = 49/100$, because $f1-f2 = 51/100 f1$ which
is not equal to $49/100 f1 = f2$.  In this case, there will be two
very closely spaced frequency components at $f2$ and $f1-f2$.  One of
the advantages of the Volterra series technique is that it computes
distortions at mix frequencies expressed symbolically (i.e. 
n$\cdot$f1 $\pm$ m$\cdot$f2), therefore one is able to obtain the
strengths of distortion components accurately even if the separation
between them is very small, as opposed to transient analysis for
example.  The disadvantage is of course that if two of the mix
frequencies coincide, the results are not merged together and
presented, though this could presumably be done as a postprocessing
step.  Currently, the interested user should keep track of the mix
frequencies and add the distortions at coinciding
mix frequencies together should it be necessary.

The optional dc sweep is a dc analysis specification which will cause
the distortion analysis to be performed at each point of the dc sweep. 
The small-signal parameters are reevaluated at every sweep point, and
the output vectors will be multidimensional.

In interactive mode, the {\cb disto} command, which takes the same
arguments as the {\vt .disto} line, can be used to initiate distortion
analysis.

Distortion analysis is not available if Josephson junctions are
included in the circuit.

%----------------------------------------------------
\subsection{{\vt .noise} Line}
\index{.noise line}
\index{noise analysis}
\index{analysis!noise}
\label{noiseline}

% spAnalysis.hlp:.noise 060219

The noise analysis portion of {\WRspice} performs analysis of
device-generated noise for the given circuit.  When provided with an
input source and an output node or current, the analysis calculates
the noise contributions of each device (and each noise generator
within the device) to the output node voltage or current.  It also
calculates the level of input noise from the specified input source
to generate the equivalent output noise.  This is done for every
frequency point in a specified range --- the calculated value of the
noise corresponds to the spectral density of the circuit variable
viewed as a stationary Gaussian stochastic process.

This is the classic frequency-domain SPICE noise analysis.  {\WRspice}
also provides the capability of simulating thermal noise in the time
domain.  See the description of the {\vt tgauss} ``tran'' function in
\ref{tgauss} for discussion and an example.

After calculating the spectral densities, noise analysis integrates
these values over the specified frequency range to arrive at the total
noise voltage/current (over this frequency range).  This calculated
value corresponds to the variance of the circuit variable viewed as a
stationary Gaussian process.

\spgen{.noise {\it out\/} {\it src\/}
 {\vt dec|oct|lin} {\it pts fstart fstop\/} [{\it
 summary\_pts\/}] [dc$|$sweep {\it args}]}
\spexamp{.noise v(5) vin dec 10 1khz 100mhz\\
.noise v(5,3) v1 oct 8 1.0 1.0e6 1 dc vee -5 -3 1}

Above, {\it out} represents the output, which can be a node voltage
in the standard form
\begin{quote}
 v({\it out\/}[,{\it ref\/}])
\end{quote}
or the current through a voltage source (or inductor) in one of the
standard and equivalent forms
\begin{quote}
 {\it Vsource}\\
 {\it Vsource\/}{\tt \#branch}\\
 {\vt i(}{\it Vsource\/}{\vt )}
\end{quote}

This directive initiates a noise analysis of the circuit.  The
parameter {\it out} is the point at which the total output noise is
desired, and if this is a voltage and {\it ref} is specified, then
the noise voltage v({\it out\/}) - v({\it ref\/}) is calculated.  By
default, {\it ref\/} is assumed to be ground.  The parameter {\it
src\/} is the name of a voltage or current source to which input
noise is referred, with {\it pts\/}, {\it fstart\/} and {\it fstop\/}
being the {\vt .ac} parameters that specify the frequency range over
which analysis is desired.  The optional {\it summary\_pts\/} is an
integer; if specified, the noise contributions of each noise
generator is produced every {\it summary\_pts\/} frequency points.

The {\vt .noise} analysis produces two plots --- one for the Noise
Spectral Density curves and one for the total Integrated Noise over
the specified frequency range.  All noise voltages/currents are in
squared units (V$^2$/Hz and A$^2$/Hz for spectral density, V$^2$ and
A$^2$ for integrated noise).

The optional dc sweep is a dc analysis specification which will cause
the noise analysis to be performed at each point of the dc sweep.  The
small-signal parameters are reevaluated at every sweep point, and the
output vectors will be multidimensional.

In interactive mode, the {\cb noise} command, which takes the same
arguments as the {\vt .noise} line, can be used to initiate noise
analysis.

Noise analysis is not available if Josephson junctions are
included in the circuit.

%----------------------------------------------------
\subsection{{\vt .op} Line}
\index{.op line}
\label{opline}

% spAnalysis.hlp:.op 021212

\spgen{.op}
The inclusion of this line in an input file will force {\WRspice} to
determine the dc operating point of the circuit with inductors shorted
and capacitors opened.  This is done automatically prior to most other
analyses, to determine the operating point of the circuit, yielding
transient initial conditions or the linearized models for nonlinear
devices for small-signal analysis.  It will not be done in transient
analysis if the {\vt uic} keyword is given in the transient analysis
specification.

{\WRspice} performs a dc operating point analysis if no other analyses
are requested.

In interactive mode, the {\cb op} command can be used to compute
the operating point.

Operating point analysis will fail due to a singular circuit matrix if
the circuit topology contains inductor and/or voltage source loops. 
Circuits containing such loops can only be simulated in transient
analysis using the {\vt uic} keyword in the analysis command, which
will cause the operating point analysis to be skipped.  On convergence
failure, {\WRspice} will check for and print a list of inductor and
voltage source names found to be connected in loops.  The dual
situation of current source/capacitor cut sets will often converge in
operating point analysis, as there is an added minimum conductance
which will keep the solution finite (but huge).

If Josephson junctions are present in the circuit, they will be taken
as shorted (actually, a resistance of 1uV/Ic) during operating
point analysis.  It is in general not possible to perform this type of
analysis on Josephson junctions.  The approach taken here may be
useful when working with hybrid semiconductor/superconductor circuits,
but in no case should one expect operating point analysis of Josephson
circuits to ``work''.  Transient analysis, which takes into account
the past history of the Josephson excitation, is required for a
complete simulation.

When computing the initial operating point for transient analysis,
after the operating point is calcualted with Josephson junctions
shorted, the Josephson junctions will be given any specified initial
voltage and phase (or these will be reset to exactly zero with no
initial conditions given).  Thus, the Josephson junctions are always
``{\vt uic}'', but the circuit is not in {\vt uic} mode unless {\vt
uic} is actually given in the transient analysis command.

In operating point analysis, any {\vt .save} or {\cb save} directives
will be ignored.  All node voltages and branch currents will be saved
in an "op" plot in interactive mode.

Given that operating point analysis is the starting point of most
types of analysis, it is critical that this step succeeds. 
Unfortunately, many circuits are prone to convergence failure at this
step, and achieving dc convergence has been one of the traditional
battles when using SPICE simulators.

The original operating point calculation algorithm, which was very
similar to the SPICE3 algorithm, was really pretty poor.  For example,
when attempting to simulate a large CMOS mixed-signal circuit, the old
convergence algorithm would iterate for several minutes before
ultimately failing.  On the other hand, HSPICE could find the
operating point within seconds (if that).

Lots of work was done to improve this, and a new algorithm is now the
default in release 3.2.15 and later.  The new algorithm seems to work
pretty well, and the Berkeley algorithms have been retained as
alternatives.  There is flexibility in algorithm choice, giving the
user some tools needed to obtain convergence of their circuits with
the fewest iterations (quickest convergence).

There are two basic ways to solve for the circuit operating point.  In
``gmin stepping'', a conductance is applied between every circuit node
and ground.  When this conductance is large enough, convergence can
always be achieved.  The conductance is then progressively reduced,
while continuing to solve the circuit equations with the previous
solution as a starting point.  If all goes well, convergence is
maintained when the conductance approaches zero, and the method
succeeds.

The second method is ``source stepping''.  In this method, all voltage
and current sources are set to zero initially, where the circuit is
guaranteed to have a trivial solution with every node at zero voltage. 
The sources are progressively ramped up, while solving the circuit
equations using the previous solution as the starting point. 
Ultimately, if convergence is maintained when the sources reach their
true values, the method succeeds.

The original Berkeley algorithm is as follows.  First, unless the
option variable {\et noopiter} is set, an attempt is made to solve the
equation set directly, without using stepping.  If convergence is
acheived within the number of iterations specified by the {\et itl1}
variable (default 400), the operating point analysis succeeds.

If, as is likely, the initial attempt fails, gmin stepping is
attempted.  In the Berkeley algorithm, the conductance is reduced by a
factor of 10 for each gmin step.  If convergence is maintained through
all steps, a final solution is attempted with no added conductance,
and if this too succeeds, operating point analysis succeeds.  However,
it is possible that at some step, convergence will fail, and thus gmin
stepping will fail.

If gmin stepping fails, or is not attempted, source stepping is tried. 
In the Berkeley algorithm, each source step is a fixed percentage of
the final value.  If convergence is maintained through all steps, then
operating point analysis succeeds.  Otherwise, the user will have to
alter the circuit or change parameters to coerce convergence in a
subsequent run.

The number of gmin and source steps is set by the option variables
{\et gminsteps} and {\et srcsteps}, both default to 10 in SPICE3, and
in earlier versions of {\WRspice}.

The new algoritm uses ``dynamic'' stepping, for both gmin and source. 
In dynamic stepping, if a step fails, the step size is cut, and the
calculation is repeated.  If the step size is cut below a threshold
after repeated failures, the method is exited with failure.  On the
other hand, if convergence is achieved with just a few iterations,
then the step size is increased.  This method is far more effective
than the original approach.  This concept was borrowed from the
open-source NGSPICE project.

The new algorithm is invoked when both the {\et gminsteps} and {\et
srcsteps} values are 0, which are the current defaults (these can be
set from the {\cb Convergence} page of the {\cb Simulation Options}
tool).  If either is positive, a modified SPICE3 algorithm is used. 
If negative (-1 is now an allowed value) that convergence method will
not be attempted.  If both are negative, a direct solution will be
attempted, whatever the state of the {\et noopiter} option variable.

The new algorithm is the following.  If either {\et gminsteps} or {\et
srcsteps} is positive, we are in a quasi-SPICE3 compatibility mode. 
In this case, if the {\et noopiter} variable is not set, the first
task is to Newton iterate the matrix to attempt direct convergence. 
If convergence is not achieved in an iteration count given by the
value of the {\et itl1} variable, this is aborted, and the stepping
options are attempted.

This initial direct convergence attempt can be very time-consuming and
is rarely successful for large circuits, thus it is not done unless
\begin{enumerate}
\item{as above, either of {\et gminsteps} or {\et srcsteps} is
positive, and {\et noopiter} is not set.}
\item{if {\et gminsteps} and {\et srcsteps} are both -1.  Direct
convergence will be attempted whether or not {\et noopiter} is
set in this case.}
\end{enumerate}

For very simple sircuits, when the direct method succeeds, this will
probably yield the fastest operating point calculation.  However, in
these simple cases the difference is too small to be noticeable by the
user, although in some automated tasks the accumulated time difference
might be important.

By default, the next attempt will use source stepping.  This is
different from SPICE3, which would attempt gmin stepping before source
stepping.  However, it appears that source stepping is more effective
on large CMOS circuits, so we try it first.  However, if the option
variable {\et gminfirst} is set, gmin stepping will be attempted
before source stepping.

The default value of {\et srcsteps} is 0, which indicates use of the
new dynamic source stepping algorithm.  This algorithm takes
variable-sized steps when raising the source values to their specified
initial values, and backs up and tries again with a smaller step on
failure.  The SPICE3 source stepping takes fixed-size steps, and
aborts on failure.  The dynamic approach is far more effective.  If
{\et srcsteps} is positive, the SPICE3 approach will be used, with the
given number of steps.  If {\et srcsteps} is -1, source stepping will
be skipped.

The gmin stepping, which is attempted if convergence has not been
achieved, is similar.  The default value of the {\et gminsteps} option
variable is 0, indicating use of the dynamic gmin stepping algorithm. 
This reduces the ``gmin'' conductivity that is added to the circuit to
achieve convergence in variable sized increments.  If convergence
fails, a smaller step is tried.  The SPICE3 gmin stepping algorithm
uses fixed-size steps (actually, orders of magnitude) when reducing
gmin, and if convergence fails, the operation is aborted.  This is
done if {\et gminsteps} is given a positive value.  The dynamic
algorithm is much more effective.  If {\et gminsteps} is given a value
-1, gmin stepping is not done.

Another difference between {\WRspice} and Berkeley SPICE is that in
{\WRspice}, the minimum value of conductance allowed on the matrix
diagonal, in any analysis mode, is the value of the {\et gmin} option
variable.  This defaults to $10^{-12}$Si.  This avoids a singular matrix
in various cases, such as series capacitors in dc analysis, or
elements that have a floating node.

There are option variables which set the number of iterations to
allow between steps when using the dynamic stepping algorithms. 
These are {\et itl2gmin} and {et itl2src}, both of which default to
20.  The ``{\et itl2}'' prefix derives from the fact that in earlier
versions of {\WRspice}, the dc sweep iteration limit was used, which
is set with the <a href="itl2"><tt>itl2</tt></a> variable and
defaults to 100.  It is probably counter-intuitive that reducing this
number is a good thing, however this proved to be effective in
solving some difficult convergence problems, in particular with some
of the Verilog-A bipolar transistor models (hicum2, mextram).  What
happens is that when iterating and not converging, the computed
matrix element entries can blow up to a point where the matrix
becomes singular, and the run aborts.  With the smaller iteration
limit, the limit is reached before the matrix becomes singular, so
the step gracefully fails, and a smaller step is then attempted,
which converges.

Operating point analysis can be halted by the user by pressing {\kb
Ctrl-C}.  However, unlike other analysis types, it can not be resumed.

If the {\et trantrace} debugging variable is set to a nonzero value,
during operating point analysis, messages will be printed giving
information about the analysis, including iteration counts and
stepsize.  This applies for any operating point calculation, not just
in transient analysis.

The {\et dcmu} option variable can be used to improve convergence
during operating point analysis.  This variable takes a value of
0.0--0.5, with the default being 0.5.  When set to a value less than
0.5, the Newton iteration algorithm mixes in some of the previous
solution, which can improve convergence.  The smaller the value, the
larger the mixing.  This gives the user another parameter to twiddle
when trying to achieve dc convergence.  This can be set from the {\cb
Convergence} page of the {\cb Simulation Options} tool.


%----------------------------------------------------
\subsection{{\vt .pz} Line}
\index{.pz line}
\index{pole-zero analysis}
\index{analysis!pole-zero}
\label{pzline}

% spAnalysis.hlp:.pz 041811

The pole-zero analysis portion of {\WRspice} computes the poles
and/or zeros in the small-signal ac transfer function.  The program
first computes the dc operating point and then determines the
linearized, small-signal models for all the nonlinear devices in the
circuit.  This circuit is then used to find the poles and zeros.

Two types of transfer functions are allowed:  one of the form (output
voltage)/(input voltage) and the other of the form (output
voltage)/(input current).  These two types of transfer functions cover
all the cases and one can find the poles/zeros of functions like
input/output impedance and voltage gain.  The input and output ports
are specified as two pairs of nodes.

The pole-zero analysis works with resistors, capacitors, inductors,
linear controlled sources, independent sources, BJTs, MOSFETs, JFETs
and diodes.  Transmission lines and Josephson junctions are not
supported.

\spgen{.pz {\it node1 node2 node3 node4\/} cur|vol pol|zer|pz}
\spexamp{.pz 1 0 3 0 cur pol\\
.pz 2 3 5 0 vol zer\\
.pz 4 1 4 1 cur pz}

The keyword {\vt cur} stands for a transfer function of the type
(output voltage)/(input current) while {\vt vol} stands for a transfer
function of the type (output voltage)/(input voltage).  The keyword
{\vt pol} stands for pole analysis only, {\tt zer} for zero analysis
only and {\vt pz} for both.  This feature is provided mainly because
if there is a nonconvergence in finding poles or zeros, then, at least
the other can be found.  Finally, {\it node1\/} and {\it node2\/} are
the two input nodes and {\it node3\/} and {\it node4\/} are the two
output nodes.  Thus, there is complete freedom regarding the output
and input ports and the type of transfer function.

In interactive mode, the {\cb pz} command, which takes the same
arguments as the {\vt .pz} line, can be used to initiate pole-zero
analysis.

Pole-zero analysis is not available if Josephson junctions are
included in the circuit.

%----------------------------------------------------
\subsection{{\vt .sens} Line}
\index{.sens line}
\index{sensitivity analysis}
\index{analysis!sensitivity}
\label{sensline}

% spAnalysis.hlp:.sens 060219

\spgen{.sens {\it outvar} [ac dec|oct|lin {\it np fstart fstop\/}]
 [dc$|$sweep {\it args}]}
\spexamp{.sens v(1,out)\\
.sens v(out) ac dec 10 100 100k\\
.sens i(vtest)}

The sensitivity of {\it outvar\/} to all non-zero device parameters is
calculated when the sensitivity analysis is specified.  The parameter
{\it outvar\/} is a circuit variable (node voltage or branch current). 
Without the ac specification, the analysis calculates sensitivity of
the dc operating point value of {\it outvar\/}.  If an ac sweep
specification is included, the analysis calculates sensitivity of the
ac values of {\it outvar\/}.  The parameters listed for ac sensitivity
are the same as in an ac analysis.  The output values are in
dimensions of change in output per unit change of input (as opposed to
percent in output or per percent of input).

The optional dc sweep is a dc analysis specification which will cause
the sensitivity analysis to be performed at each point of the dc
sweep.  The small-signal parameters are reevaluated at every sweep
point, and the output vectors will be multidimensional.

In interactive mode, the {\cb sens} command, which takes the same
arguments as the {\vt .sens} line, can be used to initiate sensitivity
analysis.

Sensitivity analysis is not available if Josephson junctions are
included in the circuit.

%----------------------------------------------------
\subsection{{\vt .tf} Line}
\index{.tf line}
\index{transfer function analysis}
\index{analysis!transfer function}
\label{tfline}

% spAnalysis.hlp:.tf 060219

\spgen{.tf {\it outsrc} | v({\it n1\/}[,{\it n2\/}]) {\vt insrc}
 [ac dec|oct|lin {\it np fstart fstop\/}]
 [dc$|$sweep {\it args}]}
\spexamp{.tf v(5,3) vin\\
.tf I(vload) vin ac dec 10 1 1e12\\
.tf v(2) vin ac dec 10 1 1meg\\
.tf v(4) vx dc vcc 5 10 1\\
.tf v(5) vy ac dec 10 1 1meg dc 5 10 1}

The {\vt .tf} line defines the small-signal output and input for the
dc or ac small-signal analysis.  The first parameter is the
small-signal output variable (node voltage or name of inductor or
voltage source for branch current) and {\it insrc\/} is the small
signal input source.  If this line is included, {\WRspice} computes
the dc or ac small-signal value of the transfer function
(output/input), input resistance or impedance, and output resistance
or impedance.  For the first example, {\WRspice} would compute the
ratio of {\vt v(5,3)} to {\vt vin}, the small signal input resistance
at {\tt vin}, and the small-signal output resistance measured across
nodes 5 and 3.  If the ac parameters are given, the {\vt .tf} line
produces output vectors representing the impedance and other
parameters at each frequency point.

The optional dc sweep is a dc analysis specification which will cause
the transfer function analysis to be performed at each point of the dc
sweep.  The small-signal parameters are reevaluated at every sweep
point, and the output vectors will be multidimensional.

In interactive mode, the {\cb tf} command, which takes the same
arguments as the {\vt .tf} line, can be used to initiate transfer
function analysis.

Transfer function analysis is not available if Josephson junctions are
included in the circuit.

%----------------------------------------------------
\subsection{{\vt .tran} Line}
\index{.tran line}
\index{transient analysis}
\index{analysis!transient}
\label{tranline}

% spAnalysis.hlp:.tran 060219

The transient analysis portion of {\WRspice} computes the transient
output variables as a function of time over a user-specified time
interval.  The initial conditions are automatically determined by a dc
analysis.  All sources which are not time dependent (for example,
power supplies) are set to their dc value.  The transient time
interval is specified on a {\vt .tran} control line.

\spgen{.tran {\it tstep1 tstop1} [[start=]{\it tstart1} [{\it tmax\/}]]
 [{\it tstep2 tstop2} ... {\it tstepN tstopN\/}] [uic]\\
 \hspace*{5mm} [scroll | segment {\it base delta\/}] [dc$|$sweep {\it args}]}
\spexamp{.tran 1ns 100ns\\
.tran 1ns 1000ns 500ns\\
.tran 10ns 1us uic}

The {\it tstep} values are the printing or plotting increments for
output, in the ranges

\begin{tabular}{ll}
{\it tstep1\/}: & {\it tstart} $<=$ {\it time} $<$ {\it tstop1}\\
{\it tstep2\/}: & {\it tstop1} $<=$ {\it time} $<$ {\it tstop2}\\
\multicolumn{2}{c}{...}\\
{\it tstepN\/}: & {\it tstopN-1} $<=$ {\it time} $<$ {\it tstopN}\\
\end{tabular}

The {\it tstart} is the initial time, assumed 0 if not given.  This
can be preceded by a ``{\vt start=}'' keyword, for HSPICE
compatibility.  The transient analysis always begins at time zero
internally.  In the interval [0, {\it tstart\/}), the circuit is
analyzed (to reach a steady state), but no outputs are stored. 
Subsequently, the circuit is analyzed and outputs are stored.

The parameter {\it tmax\/} is the maximum internal timestep size that
{\WRspice} will use.  The internal timestep is computed dynamically
from the circuit.  The output generated at the specified {\it tstep}
points is interpolated from the ``real'' internal time points.  The
{\it tmax} parameter can be used when one wishes to guarantee a
computing interval which is smaller than the output increment, {\it
tstep\/}.

If not given, the effective {\it tmax} is taken as the {\bf smaller}
of {\it tstep\/}, and ({\it tstop} -- {\it tstart\/})/50.  This is
different from Berkeley SPICE3, which chooses the larger value (which
may be a bug), and earlier releases of {\WRspice}.

It is important to understand the consequences of this difference. 
This change was made to improve results from circuits containing only
devices that weakly limit the time step (e.g.  MOSFETs, ring
oscillator results) which otherwise can be ugly and wrong.  This
allows users of such devices to get good results without having to set
an explicit maximum time step in the tran line. 
 
However, if the printing time increment {\it tstep} is too small, the
simulation time can dramatically increase, since these points are
actually being calculated and not just interpolated.  The user in this
situation has several options:

\begin{enumerate}
\item{Accept the longer analysis time as the cost of greater accuracy.}
\item{Use a larger printing time increment ({\it tstep\/}).}
\item{ Use the {\it tmax} parameter to set a larger limit.}
\item{Use {\vt .options oldsteplim} to
use the old limit of ({\it tstop\/} -- {\it tstart\/})/50.}
\end{enumerate}

The {\vt uic} keyword (use initial conditions) is an optional keyword
which indicates that the user does not want {\WRspice} to solve for
the quiescent operating point before beginning the transient analysis. 
If this keyword is specified, {\WRspice} uses the values specified
using {\vt ic=}...  on the various elements as the initial transient
condition and proceeds with the analysis.  If the {\vt .ic} line has
been given, then the node voltages on the {\vt .ic} line are used to
compute the initial conditions for the devices.  See the description
of the {\vt .ic} line (\ref{icline}) for its interpretation when {\vt
uic} is not specified.

If Josephson junctions are present in the circuit, if {\vt uic} is not
given, the operating point is computed taking the Josephson junctions
as shorted (actually, a resistance of 1uV/Ic).  After this, the
Josephson junctions will be given any specified initial voltage and
phase (or these will be reset to exactly zero with no initial
conditions given).  Thus, the Josephson junctions are always ``{\vt
uic}'', but the circuit is not in {\vt uic} mode unless {\vt uic} is
actually given in the transient analysis command.

In addition, with Josephson junctions present the value of current
flowing through all inductors in the circuit is reset to zero before
transient analysis and after the operating point is calculated.  This
is required to enforce the flux and Josephson phase relationship
around loops of Josephson junctions and inductors.  The algorithm
requires that both phase and flux start at zero, and evolve acording
to the forces applied by the rest of the circuit.

In 3.2.11 and earlier releases, the presence of Josephson junctions
would automatically cause simulation in {\vt uic} mode.  as if ``{\vt
uic}'' was included in the {\vt tran} command.  In releases after
3.2.11, the presence of Josephson junctions does not automatically
specify {\vt uic} mode.  Instead, as with simulations without
Josephson junctions, a dc operating point calculation is performed to
obtain the initial node voltages, which are used as the starting point
for transient analysis.  If Josephson junctions are present, the
calculated inductor currents are zeroed before transient analysis
starts, which is a technical requirement for maintaining the
flux/phase relationship in JJ/inductor loops.

If a circuit containing Josephson junctions has all sources with a
time=0 value of zero, then it is possible to give {\vt uic} explicitly
in the {\vt tran} command line.  This will avoid the dc operating
point analysis, and therefor perhaps simulate slightly faster.

If a circuit has sources that have nonzero time=0 values, it is not
recommended to give {\vt uic}, though it will typically work. 
Effectively, there is a large initial transient, which may initialize
multi-valued Josephson circuits into an unexpected mode, or produce
other undesirable effects.

The advantage of the present non-uic approach when simulating with
Josephson junctions is that it facilitates simulating hybrid
semiconductor/superconductor circuits.  In this case, a dc operating
point calculation is generally needed to initialize the semiconductor
circuitry.

The {\vt scroll} keyword is useful in the {\cb tran} command in
interactive mode.  If the {\vt scroll} keyword is given, the
simulation will continue indefinitely, until stopped by a {\cb stop}
command or interrupt.  The time range of data {\it tstop - tstart}
behind the current time is retained in the plot.

If the {\vt segment} keyword is given, along with a character string
token {\it base} and real value {\it delta}, individual rawfiles are
output for each range of delta as the simulation advances.  The
internal plot data are cleared after each segment is output.  The
files are named with the {\it base} given, as {\it base\/}.{\vt s00},
{\it base\/}.{\vt s01}, etc.  This will not happen if a rawfile is
being produced.  If {\vt scroll} is also given, it is ignored.  If a
dc analysis is chained, it is legitimate to pass a {\it delta} of
zero, in which case a file is produced for each cycle.  Otherwise, the
{\it delta} should be a multiple or submultiple of {\vt tstop}, or the
files will be difficult to interpret.  It is an error if {\it delta}
is nonpositive if there is no chained dc analysis.  The purpose of
this feature is to facilitate extremely lengthly transient analysis
runs.

The optional dc sweep is a dc analysis specification which will cause
the transient analysis to be performed at each point of the dc sweep. 
The dc operating point is reevaluated at every sweep point, and output
vectors will be multidimensional.  The optional parameters before {\vt
dc} can be omitted in this case, as the parser recognizes the ``{\vt
dc}'' keyword as the start of a dc sweep specification.  If the {\vt
scroll} keyword is given, the dc sweep is not available.

In interactive mode, the {\cb tran} command, which takes the same
arguments as the {\vt .tran} line, can be used to initiate transient
analysis.

\index{"@delta vector}
During transient analysis, a special vector {\vt @delta} maps to the
(most recent) internal time step.  To use in a plot, it must be saved
first (using a {\vt .save} line or the {\cb save} command).  It is
sometimes useful or interesting to see how the internal timestep
varies in a simulation.


%------------------------------------------------------------------------------
\section{Output Generation}

% spInput.hlp:output 022111

In these lines, outputs can be specified using the SPICE2 notation.  The
form is {\vt v{\it xx\/}({\it node1\/}[,{\it node2\/}])}, or
{\vt i{\it xx\/}({\it branch\_device})}.  The {\it xx} can be left out,
indicating the basic voltage or current, or be one of the following.
\begin{quote}
\begin{tabular}{ll}
\vt m & Magnitude\\
\vt p & Phase\\
\vt r & Real part\\
\vt i & Imaginary part\\
\vt db & Decibel value ($20log_{10}$)\\
\end{tabular}
\end{quote}
These forms are not usually needed for other than ac analysis.
The {\vt ({\it node1}, {\it node2\/})} notation indicates a voltage
difference between nodes {\it node1} and {\it node2}.  If {\it node2}
and the associated comma are left out, the ground node is assumed.
Output variables for noise, distortion, and some other analyses have
a different general form.  See the description of the analysis
for the output variable names.

%----------------------------------------------------
\subsection{{\vt .save} Line}
\index{.save line}
\index{.probe line}
\label{saveline}
\spgen{.save [output] {\it vector vector ...}}
\spexamp{.save i(vin) v(3)\\
.save @m1[id] vm(3,2)}

When a rawfile is produced, the vectors listed in the {\vt .save} line
are recorded in the rawfile.  The standard vector names are accepted;
for the form {\vt v}({\it a\/}, {\it b\/}), the vectors {\vt v}({\it
a\/}) and {\vt v}({\it b\/}) are saved ({\it not} the difference
vector).  The voltage vector(s) are saved for each of the forms {\vt
vm}, {\vt vp}, {\vt vr}, {\vt vi}, and {\vt vdb}.  Similarly, the
branch current is saved on mention of any of the corresponding {\vt i}
forms.  A token without parenthesis is interpreted as a node name,
e.g.~, ``1'' implies {\vt v(1)} is saved.
 
If no {\vt .save} line is given or no entries are found, then all
vectors produced by the analysis are saved.  If {\vt .save} lines are
given, only those vectors specified are saved.  The keyword ``{\vt
output}'' specifies that the vector names found in all {\vt
.print}, {\vt .plot}, and {\tt .four} lines are to be saved, in
addition to any vectors listed on the {\vt .save} lines.

In {\WRspice} release 3.2.11 and later, the keyword {\vt .probe} is a
synonym for {\vt .save}.  This is for rough compatibility with other
simulators.

There is an analogous {\cb save} command available within {\WRspice}.

%----------------------------------------------------
\subsection{{\vt .print} Line}
\index{.print line}
\spgen{.print {\it prtype ov1\/} [{\it ov2 ... ov8\/}]}
\spexamp{.print tran v(4) i(vin)\\
.print dc v(2) i(vsrc) v(23,17)\\
.print ac vm(4,2) vr(7) vp(8,3)}

The {\vt .print} line defines the contents of a tabular listing of one
to eight output variables.  The parameter {\it prtype\/} is the type
of the analysis (dc, ac, tran, noise, etc.) for which the specified
outputs are desired.  Variables can take the forms tabulated above. 
The actual format recognized is that of the {\cb print} command, which
is far more general.  There is no limit on the number of {\vt .print}
lines for each type of analysis.

%----------------------------------------------------
\subsection{{\vt .plot} Line}
\index{.plot line}
\spgen{.plot {\it pltype ov1\/} [{\it ov2\/} ... ] [({\it min\/},{\it max\/})]}
\spexamp{.plot dc v(4) v(5) v(1)\\
.plot tran v(17,5) (2,5) i(vin) v(17) (1,9)\\
.plot ac vm(5) vm(31,24) vdb(5) vp(5)\\
.plot disto hd2 hd3(R) sim2\\
.plot tran v(5,3) v(4) (0,5) v(7) (0,10)}

The {\vt .plot} line defines the contents of one plot from one or more
output variables.  In SPICE2, the number of variables was limited to
eight, but {\WRspice} has no preset limit.  In SPICE2, each variable
could be followed by a comma-separated pair of numbers in parentheses
which indicated the plotting range.  {\WRspice} supports this
construct only as the last argument, and it applies to all variables. 
The parameter {\it pltype\/} is the type of analysis (ac, dc, tran,
etc.) for which the specified outputs are desired.  The syntax for the
{\it ov}N is identical to that for the {\vt .print} line and for the
{\cb plot} command in the interactive mode.

This line generates ASCII plots in batch mode, for compatibility
with SPICE2.  The overlap of two or more traces on any plot is
indicated by the letter X.

When more than one output variable appears on the same plot, the first
variable specified is printed as well as plotted.  If a printout of
all variables is desired, then a companion {\vt .print} line should be
included.

There is no limit on the number of {\vt .plot} lines specified for
each type of analysis.

%----------------------------------------------------
\subsection{{\vt .four} Line}
\index{.four line}
\spgen{.four {\it freq ov1\/} [{\it ov2 ov3 ...\/}]}
\spexampo{.four 100k v(5)}

The {\vt .four} line controls whether {\WRspice} performs a Fourier
analysis as a part of the transient analysis.  The parameter {\it
freq\/} is the fundamental frequency, and {\it ov1,...\/}, are the
output variables for which the analysis is desired.  The Fourier
analysis is performed over the interval [{\vt tstop}-period, {\tt
tstop}], where {\vt tstop} is the final time specified in transient
analysis, and {\vt period} is one period of the fundamental frequency. 
The dc component and the first nine harmonics are determined.  For
maximum accuracy, {\vt tmax} (see the {\tt .tran} line, in
\ref{tranline}) should be set to {\it period}/100 (or less for very
high Q circuits).

%----------------------------------------------------
\subsection{{\vt .width} Line}
\index{/width line}
\spgen{.width out={\it wid}}
This line is ignored, except in batch mode.  The {\it wid} is the
number of columns to be used for printing output.  Internally, this
effectively sets the {\et width} variable.


%------------------------------------------------------------------------------
% spInput.hlp:tests 022519
\section{Parameter Measurement and Testing}

{\WRspice} has provision for parameter measurement during a
simulation, and for stopping the run on a particular event or
condition.  Internally, these are implemented from the same components
and have similar syntax and features.

%----------------------------------------------------
\subsection{{\vt .measure} Line}
\index{/measure line}
\spgen {
    measure {\it analysis} {\it resultname} {\it point} | {\it interval}
    [{\it measurements\/}] [{\it postcmds\/}]\\
    measure {\it analysis} {\it resultname} param={\it expression}
    [{\it postcmds\/}]
}

The {\vt .measure} line allows one to identify a measurement point or
interval, and to evaluate an expression at that point, or call a
number of measurement primitives that apply during the interval, such
as rise time or pulse width.  There is also a {\cb measure} command
that uses the same syntax, but will apply to all circuits when active. 
See the description of that command for information about syntax and
usage.

%----------------------------------------------------
\subsection{{\vt .stop} Line}
\index{/stop line}
\spgen {
    {\vt .stop} {\it analysis} {\it point} $|$ {\it interval}
     [{\it postcmds\/}]
}

The {\vt .stop} line allows the simulation to pause on a specified
condition.  These lines may be useful as sanity checks that will
terminate a simulation and alert the user if the simulation is
diverging from expected behavior.  There is also a {\cb stop} runop
command that uses the same syntax.  See the description of that
command for information about syntax and usage.


%------------------------------------------------------------------------------
\section{Control Script Execution}

% spInput.hlp:execblock 030519

{\WRspice} includes a script parsing and execution facility, which
uses a syntax similar to that of the UNIX C-shell and will be
described in \ref{shell}.  Statements which are interpreted and
executed by this facility can be included in circuit files through use
of the {\vt .exec}, {\vt .control}, and {\vt .postrun} tokens.  These
statements are enclosed in a block beginning with {\vt .exec}, {\tt
.control}, or {\vt .postrun} and ending with {\tt .endc}.  The {\vt
.exec}, {\tt.control}, and {\vt .postrun} keywords are followed by an
optional block name, and {\tt .endc} lines contain only the keyword.

%----------------------------------------------------
\subsection{{\vt .exec}, {\vt .control}, {\vt .postrun}, and {\vt .endc} Lines}
\index{.exec line}
\index{.control line}
\index{.postrun line}
\index{.endc line}
\index{control blocks}
\label{control}
\spgen{.exec [{\it blockname\/}]\\
{\it shell commands ...}\\
.endc\\
\\
.control [{\it blockname\/}]\\
{\it shell commands ...}\\
.endc\\
\\
.postrun [{\it blockname\/}]\\
{\it shell commands ...}\\
.endc}

\spexampo{.exec\\
set vmin = 2.5\\
.endc\\
\\
.control\\
let maxv = v(2)*v(19)\\
.endc}

The {\it shell commands} are any commands which can be interpreted by
the {\WRspice} shell.

If a {\it blockname} is given, the script lines are parsed, and the
executable object saved as a codeblock under {\it blockname\/}.  The
block can be executed by invoking the {\it blockname} from the command
line or in a script or codeblock.

In this usage, there is no difference between the {\vt .exec}, {\vt
.control}, and {\vt .postrun} keywords, and there is no connection of
the block to any other content in tne same file.  One file can be used
to load any number of named codeblocks.  Blocks with an existing name
will replace the existing content.

If the block is unnamed, the difference between {\vt .exec} and {\vt
.control} is that for {\tt .exec}, the commands are executed before
the circuit is parsed, and for {\vt .control}, the commands are
executed after the circuit is parsed, assuming that the file also
contains a circuit description.  If not, there is again no real
distinction, but unlike for named blocks, unnamed blocks will be
executed when read.


Commands in a {\vt .postrun} block are executed after every simulation
that completes normally (i.e., without errors or interrupts).  This
can be used to dump circuit data to a file, for example, without
having to explicitly give commands or write a script.

\index{variable substitution}
When the circuit is parsed, shell variable substitution (see
\ref{variablesub}) is performed.  Shell variable references begin with
`{\vt \$}', and are replaced with the text to which the shell variable
has been set, unless the character before the `{\vt \$}' is a
backslash (`$\backslash$'), which prevents substitution and is usually
taken as a comment start.  The variable can be set from the shell with
the {\cb set} command, and a variable is also set if it is given in a
{\vt .options} line.  Any text in a circuit description can reference
a shell variable, and this offers a powerful capability for
manipulating the circuit under the control of the shell.  As the
variables must be set before the circuit is parsed, the {\cb set}
commands which perform this action can be included in the {\vt .exec}
block of the circuit file itself, or in the {\vt .options} line.  For
example, suppose one has a circuit with a large number of resistors,
each the same value, but it is desired to run the circuit for several
different values.  The resistor lines could be specified as
\begin{quote}\vt
r31 11 36 \$rvalue\\
r32 12 35 \$rvalue\\
{\rm etc.}
\end{quote}
and elsewhere in the file one would have
\begin{quote}\vt
.exec\\
set rvalue = 50\\
.endc
\end{quote}
The 50 can be changed to any value, avoiding the need to change the
many resistor lines between simulation runs.  Note that the {\vt .exec}
block must be used, if {\vt .control} was used instead, the variables
would not be set until after the circuit is read, which means that they
will not be properly defined when the expansion is performed.
The {\vt .control} block is useful for initiating analysis and
post-processing.

Note that there is an alternative method of parameterization using
the {\vt .param} line.

The same effect could have been obtained from the use of the
{\vt .options} line as
\begin{quote}\vt
.options rvalue=50
\end{quote}
and, as the {\vt .options} lines are expanded after the {\tt .exec} lines
are executed, one could have the following contrived example:
\begin{quote}\vt
.exec\\
set rtmp=50\\
.endc\\
.options rvalue = \$rtmp\\
\end{quote}
The shell variables set in {\vt .exec} and {\tt control} blocks remain
set until explicitly unset, however variables set in {\vt .options}
lines are active only when the circuit is the current circuit, and cannot
be unset (with the {\cb unset} command) from the shell.  A variable set
in the {\vt .options} line will be superseded by the same variable
set from the shell, {\vt .exec} or {\tt .control} lines.

\index{executable comments}
Commands can also be included using a different mechanism, which might
be useful if the circuit file is to be used with other simulators.  This
mechanism uses comment lines to include shell commands.  If a comment
begins with the characters ``{\vt *@}'', the remainder of the line is
taken as a shell command just as if it had been enclosed in {\vt .exec}
and {\vt .endc}.  If a comment line begins with the characters ``{\tt *\#}'',
the remainder of the line is treated as if it had been enclosed in
{\vt .control} and {\tt .endc}.  Thus, in the example above, the {\tt .exec}
block could be replaced with the line
\begin{quote}\vt
*@ set rvalue = 50
\end{quote}
Obviously, this facility allows the possibility that a real comment
can be misconstrued as a shell command.  The user is suggested to
leave space after the ``{\vt *}'' in intended comments, as a general
rule.

\index{exec plot}
If a circuit contains an {\vt .exec} block, a plot structure is
created to hold any vectors defined in the {\vt .exec} block while the
circuit is parsed.  Thus, if the circuit references vectors defined in
the {\vt .exec} block, the reference will be satisfied, and the
variables will have initial values as defined in the {\vt .exec}
block.  Similar to variables, vectors can be used to pass values to
the curcuit, through use of the substitution form ``{\vt
\$\&}{\it vecname}''.

In releases 4.2.4 and earlier, this plot was temporary, and was
destroyed once the circuit lines were processed.  In present releases,
this plot is retained, if it contains any vectors.


%----------------------------------------------------
\subsection{{\vt .check}, {\vt .checkall}, {\vt .monte}, and {\vt .noexec}
 Lines}
\index{.check line}
\index{.checkall line}
\index{.monte line}
\index{.noexec line}
\index{margin analysis}

\spgen{.check\\
.checkall\\
.monte\\
.noexec}
{\WRspice} provides a built-in two-dimensional operating range analysis
as well as Monte Carlo analysis.  A complete description of the file
formats used in these analyses is provided in Chapter \ref{oprange}.  The
analysis is initiated with the {\cb check} command described in
\ref{checkcom}, or is performed immediately if in batch mode.  Files
intended for operating range or Monte Carlo analysis may contain the
keywords {\vt .check}, {\tt checkall}, or {\tt .monte}.  In each case,
the execution of the {\vt .control} block is suppressed when the
circuit is read, however the {\vt .exec} block is executed normally. 
The {\vt .noexec} keyword also suppresses execution of the {\vt
.control} block, but does not predispose the circuit to any particular
type of analysis.

The {\vt .check} line specifies operating range analysis, where the
contour of operation is to be determined.  In the two-dimensional
space of the variables being varied, the rows are evaluated from the
left until a ``pass'' condition is found.  The analysis then resumes
at the far right, working left until a ``pass'' point is found.  The
area between the pass points is never evaluated.  If there are islands
of fail points within the pass region, they will not be found with
this algorithm.  The {\vt .checkall} line, if used instead, will
evaluate all of the points.  This slows evaluation, but is more
thorough.

The {\vt .monte} line specifies Monte Carlo analysis.  The {\vt
.noexec} line simply bypasses the execution of the {\vt .control}
lines when the file is read.  It is not an error to have more than one
of these lines present in the file (but this is poor practice).  The
{\vt .monte} line has precedence, and {\vt .checkall} has precedence
over {\vt .check}.  The {\vt .noexec} is assumed if any of the other
lines are given.


%------------------------------------------------------------------------------
\section{Verilog Interface}

% spInput.hlp:verilog 032420

{\WRspice} contains a built-in Verilog parser/simulator.  Verilog is a
popular hardware description language for digital logic circuits.  The
integration of Verilog with SPICE provides a wealth of new capability:
\begin{itemize}
\item{Direct support for analog/digital mixed-mode simulations.}

\item{The ability to co-simulate in digital and anallog domains,
possibly using the digital result to validate the SPICE simulation.}
\item{The ability to create simulation control automation in a
        Verilog block.}
\item{The ability to create measurement automation in a Verilog
        block.}
\item{The ability to create pulse sources that have complex output
        and are independent of the transient time scale.}
\end{itemize}

%----------------------------------------------------
\subsection{{\vt .verilog}, {\vt .endv}  Lines}
\spgen{.verilog}
\index{.verilog line}
\index{.endv line}
\index{Verilog blocks}
In {\WRspice}, all Verilog code is placed into a block of statements
starting with a line in the form
\begin{quote}
{\vt .verilog} {\it gatedly} {\it dbgflags}
\end{quote}
and ending with a {\vt .endv} line.  The {\it gatedly} is a word
starting with `{\vt s}' or `{\vt f}' (case insensitive), any other
word is ignored.  This specifies use of slow, fast, or typical gate
delays.  If no such word appears, the default is typical.  The {\it
dbgflags} is a hex integer in C format ({\vt 0x}{\it nnnn\/}) where
the {\it nnnn} is a hex number using digits {\vt 0}--{\vt f}.  The set
bits in this number correspond to the debugging flags as would be
supplied in the {\vt -d} option to the Whiteley Research {\it VL}
Verilog simulator.  See the {\it VL} documentation for information
about the available flags.  This feature is unlikely to be useful for
most users.

The lines within Verilog block define the modules of a hierarchy,
including a top-level ``stimulus'' module.  This is ordinary Verilog
syntax, using the subset of the complete language description that is
supported by the {\it VL} simulator.

The Verilog simulation is run in parallel with transient analysis. 
Precisely how this occurs is controlled by the {\et vastep} option. 
This can be supplied on a {\vt .options} line, or set as a variable
before the simulation is run.  The value is an unsigned integer.
\begin{description}
\item{0}\\
The Verilog simulation is advanced by calling the {\cb vastep}
command, likely through a callback function called from a {\vt .stop}
line.

\item{1 (the default)}\\
The Verilog simulation is advanced at each transient analysis time
step.

\item{\it X} (positive integer greater than 1)\\
The Verilog simulation is advanced after {\it X} transient time steps.
\end{description}

When {\vt vastep} is not zero, the Verilog is actually advanced at the
first time step where the simulation time is equal to or larger than
the specified time.  If {\vt vastep} is zero, the Verilog advancement
occurs when the {\cb vastep} command is run, which if called from a
callback will execute at the current time point.  In both cases
Verilog is advanced after SPICE has converged at the point.

Signals are passed to the Verilog block with {\vt .adc} statements,
and signals from the Verilog block are accessed through referencing
voltage or current sources.

Output signals from the Verilog block are obtained through voltage or
current sources in the circuit.  The voltage/current source must refer
by name to a Verilog variable in the scope of the top module, or use
the Verilog ``dot'' path notation.  The voltage/current source is set
to the binary value of the variable, and has a built-in rise/fall time
of one time increment.  The variable reference can contain a bit or
part select field.

A good primer on Verilog is:  Samir Palnitkar, {\it Verilog HDL, A
Guide to Digital Design and Synthesis}, SunSoft Press (Prentice Hall)
ISBN 0-13-451675-3.  The full story is in IEEE Standard 1364-1995.

An example input file that uses a {\vt .verilog} block ({\vt ex8}) is
given in \ref{examples}.  Other examples including {\vt prbs.cir} and
{\vt nor\_vamc.cir} are provided with {\WRspice}.


%----------------------------------------------------
\subsection{{\vt .adc} Line}
\spgen{.adc}
\index{.adc line}
\index{Verilog interface}
This line of {\WRspice} input converts a SPICE signal into a digital
signal for the Verilog block.  Such lines are used only as an adjunct
to Verilog.

\spgen{.adc {\it digital\_var node\_name} [{\it offset}] [{\it delta}]}

The parameters have the following interpretation:

\begin{description}
\item{\it digital\_var}\\
A qualified name of a variable in the Verilog block, which
can include a range specification.
\item{\it node\_name}\\
The node of the circuit to convert, not including any ``{\vt v()"}''.
Current branches can be accessed as ``{\it name\/}{\vt \#branch}''.
\item{\it offset {\rm (optional, default 0)}}\\
An optional real number subtracted from value before conversion (default 0).
\item{\it delta {\rm (optional, default 1)}}\\
The size of an lsb for conversion.  This is optional, defaulting to 1.
\end{description}

The transfer function is:
\begin{quote}\vt
    {\it value} = {\it value} - {\it offset}\\
    if ({\it value} $>$ 0)
    \begin{quote}
        {\it value} = {\it value} + 0.5*{\it delta}\\
    \end{quote}
    else
    \begin{quote}
        {\it value} = {\it value} - 0.5*{\it delta}\\
    \end{quote}
    {\it conversion} = (integer) ({\it value\/}/{\it delta\/})
\end{quote}

The {\it offset} and {\it delta} arguments to the {\vt .adc} line can
be expressions.  These will be evaluated once only, as the circuit is
read in.

\input{elements}

