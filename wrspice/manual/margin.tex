\chapter{Margin Analysis}

% spOpRangeAnal.hlp:marganal 012709

{\WRspice} has provision for automated operating range and Monte Carlo
analysis.  Both types of analysis perform repeated simulation runs
with varying parameters, and record whether or not the circuit
``worked'' with that parameter set. Writing the code that tests
whether the circuit is functioning properly or not is probably the
major challenge in applying these analyses.  It is usually helpful
to have a thorough understanding of how the circuit behaves before
performing margin analysis.  The margin analysis is one of the later
steps in circuit design.

Both types of margin analysis can use a file format which contains the
SPICE deck plus executable statements.  There are actually two formats
recognized, one for compatibility with the JSPICE3 program, and a new
format particular to {\WRspice}.  Use of one of these formats is the
most straightforward method of initiating margin analysis, however
there are short-cuts and hooks for more advanced users.  The scripting
capability is a powerful tool, and in general allows much tedium to be
automated.


%S-----------------------------------------------------------------------------
\section{Operating Range Analysis}
\index{operating range analysis}
\label{oprange}

% spOpRangeAnal.hlp:oprng_analysis 032520

In operating range analysis, a suitably configured source file
containing a circuit description is evaluated over a two dimensional
area of parameter space, producing an output file describing a
true/false result at each evaluated point.  The algorithm and
implementation are designed to be as efficient as possible to speed
execution.  Results can be viewed graphically during or after
simulation.

\index{check command}
As with conventional circuit and command files, operating range
analysis files can be sourced by simply typing in the file name.  If
the file name happens to conflict with a {\WRspice} command, then the
file can be input with the {\cb source} command by typing
\begin{quote}
{\vt source} {\it filename}
\end{quote}
In batch mode, the operating range analysis is performed immediately. 
Otherwise, actual operating range analysis is performed with the {\cb
check} command (see \ref{checkcom}).  In batch mode, the {\cb check}
command is run automatically, if the file has certain properties to be
described.

In order to initiate margin analysis with the {\cb check} command, the
current circuit must be from a margin analysis file, or have
appropriate bound codeblocks.  Every circuit suitable for margin
analysis must have a control block which contains a shell routine
which will evaluate the circuit variables and establish whether or not
the operation is correct.  If operation is incorrect, a vector named
``{\et checkFAIL}'' must be set to a non-zero value.  Alternatively,
the script can return the value 1 to indicate trial failure.  These
control statements can be supplied in the circuit file in a block
initiated with a {\vt .control} line and ending with a {\vt .endc}
line, or through another file added as a codeblock and bound to the
``controls'' of the circuit, through use of the {\cb codeblock}
command.

\index{operating range files}
\index{.check line}
\index{.endc line}
A second block of statements, the ``header'' or ``exec'' block, is
typically required, though it is not an error if none is provided. 
This block provides initializing statements, and is executed at the
start of operating range analysis, or at the start of each trial in
Monte Carlo analysis.  This block can be provided in the circuit file
within an {\vt .exec} and an {\vt .endc} line, or can be a bound
codeblock, bound to the ``execs'' of the circuit.

\index{Monte Carlo analysis}
Monte Carlo analysis files differ from operating range files only in
the header or {\vt .exec} lines (or header codeblock).  During Monte
Carlo analysis, the header block is executed before every simulation
so that variables can be updated.  In operating range analysis
variables are initialized by the header block only once, at the start
of analysis.

\index{.monte line}
If the circuit has a line with the characters {\vt .monte}, then Monte
Carlo analysis is assumed, and the {\vt -m} option to the {\cb check}
command is unnecessary.  Similarly, a {\vt .checkall} line will imply
the checking of all points in operating range analysis, making the
{\vt -a} option to the check command unnecessary.  A line containing
the characters {\vt .check} will indicate (the default) operating
range analysis.  One of these lines must appear if the file is to be
analyzed in batch mode.  These lines also suppress the automatic
execution of the {\vt .exec} lines and the {\vt .control} lines as the
file is sourced (the {\vt .exec} lines are actually executed, but no
vectors are saved, to enable correct shell variable expansion).  A
line containing the string {\vt .noexec} appearing in the circuit file
will have the same effect.

There are a number of vectors with defined names which control
operating range and Monte Carlo analysis.  In addition, there are
relevant shell variables.  The vectors created for use in an analysis
run are assigned to a plot structure created for the analysis.  This
plot becomes the current plot after the analysis starts.  These
vectors are usually set in the header ({\vt .exec}) block, unless the
defaults are used.  They can also be set by hand, or under the control
of another script, if the current plot is the {\vt constants} plot,
before starting the analysis.  The pre-named vectors are as follows:

\begin{description}
\item{\et checkPNTS} (real, length $>= 1$)\\
\index{operating range analysis!checkPNTS}
These are the points of the scale variable (e.g., {\et time} in
transient analysis) at which the pass/fail test is applied.  If a fail
is encountered, the simulation is stopped and the next trial started. 
If not specified, the pass/fail test is applied after the trial is
finished.  The {\et checkPNTS} vector is usually set in the header
to a list of values with the {\cb compose} command.

\item{\et checkVAL1} (real, length 1)\\
\index{operating range analysis!checkVAL1}
This is the initial central value of the first parameter to be varied
during operating range analysis.  It is not used in Monte Carlo
analysis.

\item{\et checkDEL1} (real, length 1)\\
\index{operating range analysis!checkDEL1}
The first central value will be incremented or decremented by this
value between trials in operating range analysis.  It is not used in
Monte Carlo analysis.

\item{\et checkSTP1} (integer, length 1)\\
\index{operating range analysis!checkSTP1}
This is the number of trials above and below the central value.  In
Monte Carlo analysis, it partially specifies the number of simulation
runs to perform, and specifies the X-axis of the visual array used
to monitor progress (with the {\cb mplot} command).  In operating
range analysis, the default is zero.  In Monte Carlo analysis, the
default is 3.

\item{\et checkVAL2 checkDEL2 checkSTP2}\\
\index{operating range analysis!checkVAL2}
\index{operating range analysis!checkDEL2}
\index{operating range analysis!checkSTP2}
These are as above, but relate to the second parameter to be varied in
the circuit in operating range analysis.  In Monte Carlo analysis,
only {\et checkSTP2} is used, in a manner analogous to {\et
checkSTP1}.  The total number of simulations in Monte Carlo analysis
is {\vt (2*checkSTP1 + 1)*(2*checkSTP2 + 1)}, the same as would be
checked in operating range analysis.  The {\et checkSTP2} variable sets
the number of cells in the Y-axis of the plot produced by {\cb mplot}.

\item{\et checkFAIL}  (integer, length 1, 0 or nonzero)\\
\index{operating range analysis!checkFAIL}
This is the global pass/fail flag, which is set after each trial, nonzero
indicates failure.  This variable is used in both operating range and
Monte Carlo analysis.  This variable is set by the code which evaluates
the pass/fail criteria.

\item{\et opmin1, opmax1} (real, length $>= 1$)\\
\index{operating range analysis!opmin1}
\index{operating range analysis!opmax1}
The operating range analysis can be directed to find the operating
range extrema of the first parameter for each value of the second
parameter.  These vectors contain the values found, and are automatically
generated if the range finding feature is enabled.  They are not generated
in Monte Carlo analysis.

\item{\et opmin2, opmax2} (real, length $>= 1$)\\
\index{operating range analysis!opmin2}
\index{operating range analysis!opmax2}
The operating range analysis can be directed to find the operating
range extrema of the second parameter for each value of the first
parameter.  These vectors contain the values found, and are automatically
generated if the range finding feature is enabled.  They are not generated
in Monte Carlo analysis.

\item{\et range, r\_scale} (real, length $>= 1$)\\
\index{operating range analysis!range}
\index{operating range analysis!r\_scale}
If the range finder was active, these vectors are automatically
created and added to the plot.  The {\et range} vector and its scale
{\et r\_scale} contain all of the extrema data, formatted in such a
way that the path is the contour of the boundary of the pass region. 
The {\cb plot} command can be used to display this contour by entering
``{\vt plot range}''.

\item{\et value} (real, length variable)\\
\index{operating range analysis!value}
This vector can be used to pass trial values to the circuit, otherwise
shell variables are used.  This pertains to operating range and Monte
Carlo analysis.  The name of this vector can be redefined by setting
a shell variable named ``value'' to a new name.

\item{\et checkN1, checkN2} (integer, length 1)\\
\index{operating range analysis!checkN1}
\index{operating range analysis!checkN2}
These are the indices into the {\et value} array of the two parameters being
varied in operating range analysis.  The other entries are fixed. 
These vectors are not used if shell variables pass the trial values to
the circuit, and are not used in Monte Carlo analysis.

The name of these vectors can be redefined by setting a shell variable
of the same name (``checkN1'' or ``checkN2'').  The value of this
variable, if a non-numeric string token, is taken as the name of a
vector containing the index.  If the variable is set to a positive
integer, that integer will be taken as the index, and no vector is
used.

\end{description}

The shell variables are:

\begin{description}
\item{\et checkiterate} (integer 0-10)\\
\index{operating range analysis!checkiterate}
\index{checkiterate variable}
This sets the binary search depth used in finding operating range
extrema.  If not set or set to zero, the search is skipped.  The
binary search is used to find the exact values of the operating region
boundary, and has no relevance to the usual set of pass/fail outputs
generated with the {\cb check} command.  If nonzero, during operating
range analysis and {\it not} in all-points mode, the extrema for each
row and column are found, and saved in the {\et opmin1}, {\et opmax1},
{\et opmin2}, and {\et opmax2} vectors, which are then used to
generate the {\et range} and {\et r\_scale} vectors described above.

If both of the input vectors {\et checkSTP1} and {\et checkSTP2} are
unset or set to zero, the range finder behaves somewhat differently. 
In this case, if the all-points mode is active, and the file is using
an input ``value'' vector rather than shell variables for alterable
parameters, then the range of each of these parameters is determined. 
A masking facility allows some of these inputs to be skipped.  If the
all-points mode is not set, the range for the two variables is found. 
The range finder is described in more detail below.  The range finder
is not used in Monte Carlo analysis, and the {\et checkiterate}
variable is ignored in that case.

\item{\et value1, value2}\\
\index{operating range analysis!value1}
\index{operating range analysis!value2}
The {\et value1} and {\et value2} variables are set to the current
trial values to be used in the circuit (parameters 1 and 2).  The
SPICE deck should reference these variables (as {\vt \$value1} and
{\vt \$value2}) as the parameters to vary.  Alternatively, the {\it
vector} {\et value} array can be used for this purpose.  These
variables can be used in Monte Carlo analysis, but are not set
implicitly.

Instead of using shell substitution and the {\vt value1}/{\vt value2}
variables to set varying circuit parameters, one can use an internal
parameter passing method which is probably more efficient.
 
The form, given before the analysis,
\begin{quote}
{\vt set value1="\%}{\it devicelist\/}{\vt ,}{\it paramlist\/}{\vt "}
\end{quote}
sets up a direct push into the named {\it parameters} of listed {\it
devices}, avoiding shell expansion and vectors.  Note that the list
must follow a magic `{\vt \%}' character, which tells the system to
use the {\it devlist\/},{\it paramlist} syntax, as used in the {\cb
sweep} command (see \ref{psetting}).

The {\vt jjoprng2.cir} file in the examples illustrates use of this
syntax.

\end{description}

If any of the shell variables {\et value1}, {\et value2}, or a {\it
shell} variable named ``{\et value}'' are set to a string, then the
shell variable or vector named in the string will have the same
function as the assigned-to variable.  For example, if in the header
one has {\vt set value1 = C1}, then the variable reference {\vt \$C1}
would be used in the file to introduce variations, rather than {\vt
\$value1}.  Similarly, if we have issued {\vt set value = myvec}, the
vector {\et myvec} would contain values to vary (using the pointer
vectors {\et checkN1} and {\et checkN2}), and a reference would have
the form {\vt \$\&myvec[\$\&checkN1]}.  Note that the alternate
variables are not automatically defined before the circuit is parsed,
so that they should be set to some value in the header.  The default
{\vt \$value1} and {\vt \$value2} are predefined to zero.

The ``checkN1'' and ``checkN2'' names can also be set as a shell
variable, the value of which if a positive integer will supply the
index, or if a string token will redefine the name of the vector which
provides the index.

The {\et checkVAL1}, {\et checkDEL1}, etc. vectors to be used must be
defined and properly initialized, either in the deck or directly from
the shell, before analysis.

The operating range analysis sets the shell variables {\et value1} and
{\et value2} to the variables being varied.  In addition, vector
variables can be set.  This is needed for scripts such as optimization
where the parameter to be varied is required to be under program
control.  If a vector called {\et value} is defined, and a vector
called {\et checkN1} is defined, and {\vt checkN1 >= 0} and {\vt
checkN1 <} the length of {\et value}, then {\vt value[checkN1]} is set
to {\vt \$value1}.  Similarly, if a vector called {\et value} is
defined, and a vector called {\et checkN2} is defined, and {\vt
checkN2 >= 0} and {\vt checkN2 <} the length of {\et value}, then {\vt
value[checkN2]} is set to {\vt \$value2}.  Thus, instead of invoking
{\vt \$value1} and {\vt \$value2} in the SPICE text, one can instead
invoke {\vt \$\&value[\$\&checkN1], \$\&value[\$\&checkN2]}, where we
have previously defined the vectors {\et value}, {\et checkN1}, {\et
checkN2}.  Thus, the file could have a number of parameters set to
{\vt \$\&value[0], \$\&value[1], ...} .  If {\et checkN1} is set to 2,
for example, {\vt \$\&value[2]} would be varied as parameter 1.  The
unreferenced values would be fixed at predefined entries.  As
mentioned above, the ``{\et value1}'', ``{\et value2}'', ``{\et
value}'', ``{\et checkN1}'', and ``{\et chackN2}'' names can be
redefined by assigning the name of a new variable to the shell
variable name being reassigned, using the {\cb set} command.

There are a number of ways to introduce the trial variations into the
circuit.  Of these, we have explicitly identified shell variable and
vector substitution.  Below is a review of these methods.

\begin{enumerate}
\item{
Perhaps the most direct method is to include the forms {\vt \$value1}
and {\vt \$value2} (if two dimensional) for substitution in the
current circuit.  The variables will be replaced by the appropriate
numerical values before each trial, as for shell variable
substitution.
}

\item{
If a variable named ``{\vt value1}'' is set to a string token with the
{\cb set} command, then a variable of the same name as the string
token will hold the trial values, instead of {\vt value1}.  The same
applies to {\vt value2}.  Thus, for example, if the circuit contains
expansion forms of the variables {\vt foo1} and {\vt foo2} (i.e., {\vt
\$foo1} and {\vt \$foo2}), one could perform an analysis using these
variables by giving

\begin{quote}
{\vt set value1 = foo1 value2 = foo2}
\end{quote}
}
       
\item{
The method above allows the SPICE options to be set.  These are the
built-in keywords, which can be set with the {\cb set} command or in a
{\vt .options} line in an input file, which control or provide
parameters to the simulation.

The most important example is temperature, using the {\vt temp}
option.  To include temperaure as one of the parameters to vary, one
could provide, for example

\begin{quote}
{\vt set value1=temp}
\end{quote}
}

\item{
If there are existing vectors named ``{\vt checkN1}'' and (if two
dimensions) ``{\vt checkN2}'' that contain integer values, and the
variable named ``{\vt value}'' is set to the name of an existing
vector (or a vector named ``{\vt value}'' exists), then the vector
components indexed by {\vt checkN1} and {\vt checkN2} will hold trial
values, if within the size of the vector.  For example:

\begin{quote}
{\vt let vec[10] = 0}\\
{\vt let checkN1 = 5 checkN2 = 6}\\
{\vt set value = vec}
\end{quote}

The first line creates a vector named ``{\vt vec}'' of size sufficient
to contain the indices.  The iterated values will be placed in {\vt
vec[5]} and {\vt vec[6]}.  The circuit should reference these values,
either through shell substitution (e.g., {\vt \$\&vec[5]}) or directly
as vectors.

Alternatively, a variable named ``{\vt checkN1}'' can be set.  If the
value of this variable is an integer, that integer will be used as the
index.  If the variable is a name token, then the index will be
supplied by a vector of the given name.  The same applies to {\vt
checkN2}.  The following example illustrates these alternatives:

\begin{quote}
{\vt let vec[10] = 0}\\
{\vt set checkN1 = 5}\\
{\vt let foo = 6}\\
{\vt set checkN2 = foo}
\end{quote}
}

\item{
Given that it is possible to set a vector as if a variable, by using
the {\cb set} command with the syntax

\begin{quote}
{\vt set \&}{\it vector} {\vt =} {\it value}
\end{quote}

it is possible to place trial values into vectors during analysis. 
The form above is equivalent to

\begin{quote}
{\vt let} {\it vector} {\vt =} {\it value}
\end{quote}

Note, however, that the `{\vt \&}' character has special significance
to the {\WRspice} shell, so when this form if given on the command
line the ampersand should be quoted, e.g., by preceding it with a
backslash.

Thus, suppose that the circuit depends on a vector named {\vt delta}. 
One can set up trial substitution using this vector as

\begin{quote}
{\vt set value1 = '\&delta'}
\end{quote}
}

\item{
The construct above can be extended to ``special'' vectors,
which enable device and model parameters to be set ahead of the
next analysis.  These special vectors have the form

\begin{quote}
{\vt @}{\it devname\/}{\vt [}{\it param\/}{\vt ]}
\end{quote}

where {\it devname} is the name of a device or model in the circuit,
and {\it param} is one of the parameter keywords for the device or
model.  These keywords can be listed with the {\cb show} command.

For example, if the circuit contains a MOS device {\vt m1} one might
have

\begin{quote}
{\vt set value1 = '\&@m1[w]'}
\end{quote}

This will perform the analysis while setting the {\vt m1}
{\vt w} (device width) parameter as parameter 1.
}
\end{enumerate}

The range is constructed by row, where columns represent different values
for {\et value1}.  A second pass fills in concave contours in column
order, thus the same pattern should be obtained independently of the
parameter ordering.  Patterns with islands or reentrancy may not
be displayed correctly.  The only way to make the algorithm completely
foolproof is to check every point, which is achieved by giving the
{\vt -a} option to the {\cb check} command, or by using {\vt .checkall}.

\index{operating range analysis!finding endpoints}
During the analysis, a binary search can be employed to determine the
actual values of the edges of the operating region.  This feature is
enabled by setting the shell variable {\et checkiterate} to some value
between 1 and 10.  This is the depth of the binary search used to find
the endpoint.  A binary search will be performed during conventional
operating range analysis only, and is skipped (other than in the
exception noted below) if in all-points mode ({\vt -a} flag or {\vt
.checkall} line given).  The search is skipped if there are no pass
points in the row or column.  The computed values are stored in the
{\et opmin1}, etc. vectors, where the zeroth element corresponds to
the lowest value of the fixed parameter.  For example, {\vt opmin1[0]}
is the minimum value of parameter 1 when parameter 2 is value2 -
steps2*delta2.  Entries of these vectors corresponding to points that
were not found are zero.

The value to set for the {\et checkiterate} variable is a trade-off
between accuracy and execution time.  If the boundary is found within
the parameter range defined by the input vectors (and as plotted with
the {\cb mplot} command), the error is bounded by $delta/2^n$, where
{\it delta} is the appropriate {\et checkDEL1} or {\et checkDEL2}
value, and {\it n} is the {\et checkiterate} value.  If the extremum
is found outside of the given parameter space, the error may be
$val/2^n$, where {\it val} is the value at the edge of the parameter
space nearest the solution.

After an operating range analysis with range finding is complete, two
new vectors, {\et range} and {\et r\_scale}, are created from the {\et
opmin1}, etc. vectors and added to the current plot.  These vectors
incorporate all of the nonzero entries in such a way that they form a
path describing the boundary of the operating region, with {\et range}
containing Y-data and {\et r\_scale} containing X-data.  This contour
can be displayed by plotting the {\et range} vector with the {\cb
plot} command.

The algorithm used the evaluate a row is shown below.  This is the
normal algorithm; if the {\vt -a} flag is given to the {\cb check}
command, or a {\vt .checkall} line was found in the file, the points
are simply stepped through, and no binary searching is done.

{\raggedright
\qquad for each value2 value \{\\
\qquad\qquad start at left\\
\qquad\qquad value1 = central1 - delta1 * nsteps1\\
\qquad\qquad loop \{\\
\qquad\qquad\qquad analyze\\
\qquad\qquad\qquad record point\\
\qquad\qquad\qquad if (pass) break\\
\qquad\qquad\qquad value1 = value1 + delta1\\
\qquad\qquad\qquad if (value1 $>$ central1 + delta1 * nsteps1) break\\
\qquad\qquad \}\\
\qquad\qquad if (pass)\\
\qquad\qquad\qquad do binary search for lower extremum\\[2ex]
\qquad\qquad start at right\\
\qquad\qquad value1 = central1 + delta1 * nsteps1\\
\qquad\qquad loop \{\\
\qquad\qquad\qquad analyze\\
\qquad\qquad\qquad record point\\
\qquad\qquad\qquad if (pass) break\\
\qquad\qquad\qquad value1 = value1 - delta1\\
\qquad\qquad\qquad if (value1 $<$ central1 - delta1 * nsteps1) break\\
\qquad\qquad \}\\
\qquad\qquad if (pass)\\
\qquad\qquad\qquad do binary search for upper extremum\\
\qquad \}\\[2ex]}

If both {\et checkSTP1} and {\et checkSTP2} are zero or not defined,
the range finder can have an additional operating mode.  This mode is
made active if the all-points mode is active ({\vt -a} option or {\vt
.checkall} given), and a vector is being used to supply trial values,
rather than shell variables.  If a vector named ``value'' is defined,
or a vector defined whose name is assigned to the shell variable named
``value'', the range of each of the components can be computed.  Note
that the vector can have arbitrarily many entries, and each of these
ranges can be found.  The range finding can be skipped for certain
entries by defining a mask vector.  This is a vector with the same
length as the {\et value} vector, and the same name as the {\et value}
vector but suffixed with ``{\vt \_mask}'' as in {\et value\_mask}. 
Each non-zero entry in the mask signifies that the corresponding
variable in the {\et value} array will {\it not} be tested for range. 
Additionally, any entry in the {\et value} vector which is zero will
not be tested.  If no mask vector is defined, the range will be
computed for all nonzero entries.  The results are placed, somewhat
arbitrarily, in the {\et opmin1} and {\et opmax1} vectors, which will
have lengths equal to that of the {\et value} vector.  Skipped entries
will be zero.  No {\et range} vector will be produced, since it is not
relevant in this mode.

If not in all-points mode, the range will be computed for the shell
variables.  The {\et opmin1}, etc. will contain the maximum and
minimum values (length 1).  The {\et range} vector will contain the
four points found.  Note that the central value must be a pass point
in either of these modes, or the range finding is skipped.  There is
no output file produced when both {\et checkSTP1} and {\et checkSTP2}
are zero or undefined.

One can keep track of the progress of the analysis in two ways. 
{\WRspice} will print the analysis point on the screen, plus indicate
whether the circuit failed or passed at the point, if the {\vt -v}
option is given to the {\cb check} command.  Shell {\cb echo} commands
can be used in the executable blocks to provide more information on
screen, and echoed output is printed whether or not {\vt -v} is given. 
The second method uses the {\cb mplot} command, which graphically
records the pass/fail points.  If ``{\vt mplot -on}'' is given before
the analysis, the results are plotted as simulation proceeds.

During operating range analysis, a file named {\it basename\/}.{\vt
d}{\it xx} is created in the current directory, where {\it basename}
is the base name of the input file, and {\it xx} is 00--99, set
automatically to avoid clobbering existing files.  The output file
name is stored in the {\et mplot\_cur} shell variable.

There is a special {\cb echof} command that allows text to be printed
in the output file.  The {\cb echof} command is used exactly as the
{\cb echo} command.  If there is no output file open, the command
returns with no action.  The {\cb echof} command can be used in either
{\vt .control} or {\vt .exec} blocks in the input file.


%S-----------------------------------------------------------------------------
\section{Operating Range Analysis File Format}

% spOpRangeAnal.hlp:oprngfile 040110

\index{operating range analysis!file format}
There are two recognized file formats which can be used as input for
operating range analysis.  One, the ``old format'', is retained for
compatibility with an older version of SPICE.  {\WRspice} recognizes a
second ``new format'' which is more consistent with standard {\WRspice}
input file organization.  In both cases, the input file which
specifies operating range analysis consists of three sections:

\begin{enumerate}
\item an initializing header
\item a body of control statements
\item the circuit description
\end{enumerate}

%SU-------------------------------------
\subsection{Initializing Header}
In the old format, the file must begin with a line containing only the
string
\begin{quote}
{\vt .check}
\end{quote}
which is followed by shell commands.  The header block in the old format
is terminated with a line containing only the string
\begin{quote}
{\vt .control}
\end{quote}
which also begins the control statement block.

In the new format, the first line of the file is taken to be a title
line and is otherwise ignored, consistent with other types of input files
for {\WRspice}.  The header statements are found within a block which
starts with a line containing only the string
\begin{quote}
{\vt .exec}
\end{quote}
and ends with a line containing only the string
\begin{quote}
{\vt .endc}
\end{quote}
in other words, a standard {\vt .exec} block.  The comment prefix
{\vt *@} can also be used to enter header block text, as in described
in \ref{control}.  The new format file for margin analysis should also
contain a line with only the string
\begin{quote}
{\vt .check}
\end{quote}
somewhere in the text.  Unlike the old format, the ordering of the
{\vt .exec block} and the {\vt .check} line is unimportant.

The lines in the header block initialize internally defined variables.  The
variables are those listed above as user-set, including the
{\et checkiterate} shell variable.  Variables which are not used (such as
those for variable 2 in a one dimensional case) can be ignored.

An example header is given below:\\
\begin{quote}
Old format:\\
{\raggedright\vt
.check\\
compose checkPNTS values 50p 100p 150p 200p\\
checkVAL1 = 12\\
checkDEL1 = .5\\
checkSTP1 = 5\\
checkVAL2 = .5\\
checkDEL2 = .1\\
checkSTP2 = 2\\}
\end{quote}
\begin{quote}
New format:\\
{\raggedright\vt
* Title for this file\\
.check\\
.exec\\
compose checkPNTS values 50p 100p 150p 200p\\
checkVAL1 = 12\\
checkDEL1 = .5\\
checkSTP1 = 5\\
checkVAL2 = .5\\
checkDEL2 = .1\\
checkSTP2 = 2\\}
.endc\\
\end{quote}

The variables {\et checkFAIL}, {\et checkSTP1}, and {\et checkSTP2}
are integers.  The other variables are real, except for {\et
checkPNTS} which is a real vector.

The header block can also be supplied as a bound codeblock.
This is accomplished, for example, with the command
\begin{quote}\vt
codeblock -abe {\it filename}
\end{quote}
where {\it filename} is the name of a file which contains the
statements to be used in the header block.  If an {\vt .exec} codeblock
is bound to the circuit, the bound block is executed rather than any
locally specified header block.

%SU-------------------------------------
\subsection{Control Statements}
The control statement block is almost identical in the old and new
formats.  In the old format, the control block immediately follows the
header block, though in the new format this is not necessary.  The
control statements are evaluated at each of the {\et checkPNTS}, and
set the {\et checkFAIL} flag if the logic determines that the circuit
run has failed.

This control block begins with a line containing only the string
\begin{quote}
{\vt .control}
\end{quote}
and ends with a line containing only
\begin{quote}
{\vt .endc}
\end{quote}
i.e., the standard form for a {\WRspice} control block (see \ref{control}).

The enclosed lines are {\WRspice} script statements that perform a
logical comparison of circuit variables and set the {\et checkFAIL}
variable accordingly.

The control block can also be supplied as a bound codeblock.
This is accomplished, for example, with the command
\begin{quote}\vt
codeblock -ab {\it filename}
\end{quote}
where {\it filename} is the name of a file which contains the statements
to be used in the control block.  If a {\vt .control} codeblock is bound to
the circuit, the bound block is executed rather than any locally
specified control block.

%SU-------------------------------------
\subsection{Circuit Description}
In the old format, the circuit description starts immediately after the
end of the control block, with the title line.  In the new format, the
title line is the first line of the file, and the circuit description is
by definition what is left after removing the {\vt .exec} and {\vt .control}
blocks.

This circuit description section of the file consists of conventional
{\WRspice} format circuit description lines.  The parameters to be
varied are replaced with {\vt \$value1} and {\vt \$value2}. 
Alternatively, one can define a vector called {\et value}, and unit
length vectors {\et checkN1} and {\et checkN2}.  Then, the parameters
to be varied can be replaced with {\vt \$\&value[\$\&checkN1]} and
{\vt \$\&value[\$\&checkN2]}.  During analysis, the {\vt \$value1} and
{\vt \$value2} (and the value vector entries, if used) are replaced
with the current values of the variables.

\index{concatenation character}
Note that in the circuit description, it is often useful to use the
concatenation character {\vt \%} to add a suffix.  For examples, the file
line might be
\begin{quote}
{\vt v1 0 1 pulse (0 5m 10p ...)}
\end{quote}
where we want to vary the ``{\vt 5m}''.  If the value of {\vt \$value1}
is 5, one
could replace this line with
\begin{quote}
{\vt v1 0 1 pulse (0 \$value1\%m 10p ...)}
\end{quote}

Without the {\vt \%}, the variable substitution would fail.  Alternatively,
one could set {\vt \$value1} to 5e-3, and not use the ``{\vt m}'' suffix
in the file.

The concatenation character can be set to a different character with
the {\et var\_catchar} variable.  If this variable is set to a string
consisting of a single punctuation character, then that character
becomes the concatenation character.


%S-----------------------------------------------------------------------------
\section{Example Operating Range Analysis Control File}

% not in help

The listing that follows is an operating range analysis control file
for a Josephson binary counter circuit.

\index{operating range analysis!example}
\begin{verbatim}
    3 stage Josephson counter, operating range analysis
    .check
    .exec
    # Margins of a Josephson binary counter
    # This is an example of an operating range analysis input file
    #
    # After sourcing the file, optionally enter "mplot -on" to see results
    # graphically, then "check" to initiate run.  The results will be left
    # in a file.
    #
    compose checkPNTS values 50p 135p 185p 235p 285p 335p 385p 435p 485p
    checkFAIL = 0
    # above two lines are required in header, the rest are optional
    #
    # central value of first variable, number of evaluation steps above and
    # below, step delta:
    checkVAL1 = 13
    checkSTP1 = 5
    checkDEL1 = .5
    #
    # same thing for second variable
    checkVAL2 = 38
    checkSTP2 = 5
    checkDEL2 = 1
    #
    # one can define other initialized constants here as well
    failthres = 1
    #
    # end of header
    .endc
    .control
    #
    # The following code is evaluated just after the time variable exceeds
    # each one of the checkPNTS
    #
    if time > checkPNTS[0]
            if time < checkPNTS[1]
    # time is 50p, set quiescent phase differences.  Uninitialized variables
    # do not require declaration in header
                    p0 = v(200) - v(201)
                    p1 = v(300) - v(301)
                    p2 = v(400) - v(401)
                    checkFAIL = 0
    # echo "tp1" to screen
                    echo tp1
            end
    end
    if time > checkPNTS[1]
            if time < checkPNTS[2]
    # time = 135p, state should be '001'. if not set checkFAIL to 1
    # pi and the other variables in the 'constants' plot are known
                    if abs(v(200) - v(201) + p0 - 2*pi) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(300) - v(301) - p1) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(400) - v(401) - p2) > failthres
                            checkFAIL = 1;
                    end
                    echo tp2
            end
    end
    if time > checkPNTS[2]
            if time < checkPNTS[3]
    # time = 185p, state should be '010'. if not set checkFAIL to 1
                    if abs(v(200) - v(201) - p0) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(300) - v(301) + p1 - 2*pi) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(400) - v(401) - p2) > failthres
                            checkFAIL = 1;
                    end
                    echo tp3
            end
    end
    if time > checkPNTS[3]
            if time < checkPNTS[4]
    # time = 235p, state should be '011'. if not set checkFAIL to 1
                    if abs(v(200) - v(201) + p0 - 2*pi) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(300) - v(301) + p1 - 2*pi) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(400) - v(401) - p2) > failthres
                            checkFAIL = 1;
                    end
                    echo tp4
            end
    end
    if time > checkPNTS[4]
            if time < checkPNTS[5]
    # time = 285p, state should be '100'. if not set checkFAIL to 1
                    if abs(v(200) - v(201) - p0) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(300) - v(301) - p1) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(400) - v(401) + p2 - 2*pi) > failthres
                            checkFAIL = 1;
                    end
                    echo tp5
            end
    end
    if time > checkPNTS[5]
            if time < checkPNTS[6]
    # time = 335p, state should be '101'. if not set checkFAIL to 1
                    if abs(v(200) - v(201) + p0 - 2*pi) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(300) - v(301) - p1) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(400) - v(401) + p2 - 2*pi) > failthres
                            checkFAIL = 1;
                    end
                    echo tp6
            end
    end
    if time > checkPNTS[6]
            if time < checkPNTS[7]
    # time = 385p, state should be '110'. if not set checkFAIL to 1
                    if abs(v(200) - v(201) - p0) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(300) - v(301) + p1 - 2*pi) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(400) - v(401) + p2 - 2*pi) > failthres
                            checkFAIL = 1;
                    end
                    echo tp7
            end
    end
    if time > checkPNTS[7]
            if time < checkPNTS[8]
    # time = 435p, state should be '111'. if not set checkFAIL to 1
                    if abs(v(200) - v(201) + p0 - 2*pi) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(300) - v(301) + p1 - 2*pi) > failthres
                            checkFAIL = 1;
                    end
                    if abs(v(400) - v(401) + p2 - 2*pi) > failthres
                            checkFAIL = 1;
                    end
            end
    end
    #
    # end of pass/fail logic
    .endc
    .tran 1p 500p uic
    .subckt count 1 4 5 6 7
    c1 4 0 3.2p
    r1 3 8 .4
    r2 4 9 1.1
    b1 3 0 6 jj1
    b2 5 0 7 jj1
    l1 3 4 2.0p
    l2 4 5 2.0p
    l3 1 2 2.0p
    l4 2 0 2.0p
    l5 8 0 1.4p
    l6 9 0 .1p
    k1 l1 l3 .99
    k2 l2 l4 .99
    .ends count
    r1 17 2 50
    r2 1 6 50
    r3 1 10 50
    r4 1 14 50
    r5 3 18 50
    r6 7 13 50
    r7 11 13 50
    r8 15 13 50
    r9 3 20 50
    r10 4 5 .43
    r11 8 9 .43
    r12 12 19 .43
    r13 16 30 .5
    l1 5 6 2.1p
    l2 9 10 2.1p
    l3 19 14 2.1p
    l4 30 0 2p
    x1 3 2 4 100 101 count
    x2 7 6 8 200 201 count
    x3 11 10 12 300 301 count
    x4 15 14 16 400 401 count
    *
    * These are the sources which vary
    * In general, the $value1 or $value2 symbols can replace any numerical
    * parameter in the circuit description.  No checking is done as to whether
    * the substitution makes sense.
    *
    *flux bias
    v1 13 0 pulse(0 $value1%m 10p 10p)
    *gate bias
    v2 1 0 pulse(0 $value2%m 10p 10p)
    *
    *
    v3 20 0 pwl(0 0	70p 0
    + 75p  15m 90p  15m 100p -15m 115p -15m 
    + 125p 15m 140p 15m 150p -15m 165p -15m
    + 175p 15m 190p 15m 200p -15m 215p -15m
    + 225p 15m 240p 15m 250p -15m 265p -15m
    + 275p 15m 290p 15m 300p -15m 315p -15m
    + 325p 15m 340p 15m 350p -15m 365p -15m
    + 375p 15m 390p 15m 400p -15m 415p -15m
    + 425p 15m 440p 15m 450p -15m 465p -15m 500p -15m)
    *
    * flux bias first stage
    v4 18 0 pulse(0 13m 10p 10p)
    *gate bias first stage
    v5 17 0 pulse(0 39m 8p 10p)
    *
    *Nb 3000 A/cm2   area = 20 square microns
    .model jj1 jj(rtype=1,cct=1,icon=10m,vg=2.8m,delv=0.08m,
    + icrit=0.6m,r0=49.999998,rn=2.745098,cap=0.777093p)
    .end
\end{verbatim}


%S-----------------------------------------------------------------------------
\section{Monte Carlo Analysis}
\index{Monte Carlo analysis}

% spOpRangeAnal.hlp:monte 012709

{\WRspice} has a built-in facility for performing Monte Carlo
analysis, where one or more circuit variables are set according to
a random distribution, and the circuit analyzed for functionality. 
The file formats and operation are very similar to operating range
analysis.

As in operating range analysis, a complete input file consists of
three sections: a header, an executable script analyzing operation,
and the circuit deck.  Unlike operating range analysis, however, the
header block is executed before every simulation run, so that circuit
variables may be changed (not just initialized) in the header.  As in
operating range analysis, an ``old format'' and a ``new format'' are
recognized.  These formats are identical in Monte Carlo analysis,
except that instead of a line containing the string {\vt .check}, Monte
Carlo files contain the keyword {\vt .monte}.  This must be the first
line of the file in the old format, but can appear anywhere in a new
format file.  If both keywords appear in the file (not a good idea),
then Monte Carlo analysis is assumed.

As with conventional circuit and command files, Monte Carlo analysis
files can be sourced by simply typing in the file name.  If the file
name happens to conflict with a command, then the file can be input
with the {\cb source} command.  If not in batch mode, the analysis is
initiated with the {\cb check} command, otherwise the analysis is
performed immediately.

\index{.monte line}
Monte Carlo analysis is enforced by supplying the {\vt -m} option to
the {\cb check} command, which initiates analysis.  The {\vt -m}
option is only necessary if the input file does not contain a {\vt
.monte} line.  If the {\vt -r} option is given, the simulations will
be parceled out to remote servers, allowing parallelism in
computation.

Output from a Monte Carlo run is saved in a file with base name that
of the circuit, with a suffix ``{\vt .m}{\it xx}'', where {\it xx} is
a sequentially assigned number so as to make the file name unique. 
The output file name is stored in the {\et mplot\_cur} shell variable.

The number of runs performed in Monte Carlo analysis is set by the
{\et checkSTP1} and {\et checkSTP2} variables, as in operating range
analysis.  The number of points will be {\vt (2*checkSTP1 +
1)*(2*checkSTP2 + 1)}.  If the values are not given, they default to 3
(49 points).

In Monte Carlo analysis, the header block is executed before each
simulation.  In the header block, shell variables and vectors may be
set for each new trial.  These variables and vectors can be used in
the SPICE text to modify circuit parameters.  The names of the
variables used, and whether to use vectors or variables, is up to the
user (variables are a little more efficient).  Monte Carlo analysis
does not use predefined names for parameter data.  Typically, the {\vt
gauss} function is used to specify a random value for the variables
in the header block.

It is possible to use {\vt .param} defines to introduce random values
in Monte Carlo analysis, as well as shell variables and vectors. 
Parameters defined in {\vt .param} lines are recomputed at the start
of each trial, before the {\vt .exec} block is evaluated.  Random
values can be set by calling the random number generation functions
({\vt unif}, {\vt aunif}, {\vt gauss}, {\vt agauss}, {\vt limit}).

Parameters are visible in the {\vt .exec} block if the {\vt .exec}
block is defined in the same file as the circuit (directly or through
an {\vt .include}).  Parameters are {\bf not} visible in the {\vt
.control} block.  Parameters are not visible in bound codeblocks.

\index{echof command}
There is a special {\cb echof} command that allows text to be
printed in the output file.  This is the means by which the trial
values are recorded, as there is no default recording mechanism. 
The file by default records only the success or failure of each run. 
The {\cb echof} command is used exactly as the {\cb echo} command. 
If there is no output file open, the command returns with no action. 
The {\cb echof} command can be used in either {\vt .control} or {\vt
.exec} blocks in the input file.

\index{mplot command}
Monte Carlo results can be viewed during analysis ar afterward with
the {\cb mplot} command.  Giving ``{\vt mplot -on}'' will display
results while simulating, as in operating range analysis.  The display
consists of {\vt (2*checkSTP1 + 1) * (2*checkSTP2 + 1)} squares, as in
operating range analysis, with each square indicating pass or fail. 
In Monte Carlo analysis, the squares are simply filled in in sequence,
and their placement has nothing to do with the actual circuit values.


%S-----------------------------------------------------------------------------
\section{Example Monte Carlo Analysis Control File}

% not in help

The following is an example new format Monte Carlo input file:

\index{Monte Carlo analysis!example}
\begin{verbatim}
    3 stage counter
    .exec
    # Monte Carlo analysis of a Josephson binary counter
    # This is an example of a Monte Carlo analysis input file
    #
    compose checkPNTS values 50p 135p 185p 235p 285p 335p 385p 435p 485p
    #
    set value1 = $&(13*gauss(.2,1))
    set value2 = $&(38*gauss(.2,1))
    # put the values in the output file
    echof $value1 $value2
    #
    # one can define other initialized constants here as well
    failthres = 1
    #
    # end of header
    .endc
    .control
    #
    # The following code is evaluated just after the time variable exceeds
    # each one of the checkPNTS
    #
    echo $&time
    if time > checkPNTS[0]
        if time < checkPNTS[1]
    # time is 50p, set quiescent phase differences.  Uninitialized variables
    # do not require declaration in header
            p0 = v(200) - v(201)
            p1 = v(300) - v(301)
            p2 = v(400) - v(401)
            checkFAIL = 0
            echo Test values: $value1 $value2
        else
            echo -n "  Checking at time $&time ... "
        end
    end
    if time > checkPNTS[1]
        if time < checkPNTS[2]
    # time = 135p, state should be '001'. if not set checkFAIL to 1
    # pi and the other variables in the 'constants' plot are known
            if abs(v(200) - v(201) + p0 - 2*pi) > failthres
                checkFAIL = 1;
            end
            if abs(v(300) - v(301) - p1) > failthres
                checkFAIL = 1;
            end
            if abs(v(400) - v(401) - p2) > failthres
                checkFAIL = 1;
            end
        end
    end
    if time > checkPNTS[2]
        if time < checkPNTS[3]
    # time = 185p, state should be '010'. if not set checkFAIL to 1
            if abs(v(200) - v(201) - p0) > failthres
                checkFAIL = 1;
            end
            if abs(v(300) - v(301) + p1 - 2*pi) > failthres
                checkFAIL = 1;
            end
            if abs(v(400) - v(401) - p2) > failthres
                checkFAIL = 1;
            end
        end
    end
    if time > checkPNTS[3]
        if time < checkPNTS[4]
    # time = 235p, state should be '011'. if not set checkFAIL to 1
            if abs(v(200) - v(201) + p0 - 2*pi) > failthres
                checkFAIL = 1;
            end
            if abs(v(300) - v(301) + p1 - 2*pi) > failthres
                checkFAIL = 1;
            end
            if abs(v(400) - v(401) - p2) > failthres
                checkFAIL = 1;
            end
        end
    end
    if time > checkPNTS[4]
        if time < checkPNTS[5]
    # time = 285p, state should be '100'. if not set checkFAIL to 1
            if abs(v(200) - v(201) - p0) > failthres
                checkFAIL = 1;
            end
            if abs(v(300) - v(301) - p1) > failthres
                checkFAIL = 1;
            end
            if abs(v(400) - v(401) + p2 - 2*pi) > failthres
                checkFAIL = 1;
            end
        end
    end
    if time > checkPNTS[5]
        if time < checkPNTS[6]
    # time = 335p, state should be '101'. if not set checkFAIL to 1
            if abs(v(200) - v(201) + p0 - 2*pi) > failthres
                checkFAIL = 1;
            end
            if abs(v(300) - v(301) - p1) > failthres
                checkFAIL = 1;
            end
            if abs(v(400) - v(401) + p2 - 2*pi) > failthres
                checkFAIL = 1;
            end
        end
    end
    if time > checkPNTS[6]
        if time < checkPNTS[7]
    # time = 385p, state should be '110'. if not set checkFAIL to 1
            if abs(v(200) - v(201) - p0) > failthres
                checkFAIL = 1;
            end
            if abs(v(300) - v(301) + p1 - 2*pi) > failthres
                checkFAIL = 1;
            end
            if abs(v(400) - v(401) + p2 - 2*pi) > failthres
                checkFAIL = 1;
            end
        end
    end
    if time > checkPNTS[7]
        if time < checkPNTS[8]
    # time = 435p, state should be '111'. if not set checkFAIL to 1
            if abs(v(200) - v(201) + p0 - 2*pi) > failthres
                checkFAIL = 1;
            end
            if abs(v(300) - v(301) + p1 - 2*pi) > failthres
                checkFAIL = 1;
            end
            if abs(v(400) - v(401) + p2 - 2*pi) > failthres
                checkFAIL = 1;
            end
    end
    if time > checkPNTS[1]
        if checkFAIL <> 0
            echo FAILED
        else
            echo OK
        end
    end
    #
    # end of pass/fail logic
    .endc
    .tran 1p 500p uic
    .subckt count 1 4 5 6 7
    c1 4 0 3.2p
    r1 3 8 .4
    r2 4 9 1.1
    b1 3 0 6 jj1
    b2 5 0 7 jj1
    l1 3 4 2.0p
    l2 4 5 2.0p
    l3 1 2 2.0p
    l4 2 0 2.0p
    l5 8 0 1.4p
    l6 9 0 .1p
    k1 l1 l3 .99
    k2 l2 l4 .99
    .ends count
    r1 17 2 50
    r2 1 6 50
    r3 1 10 50
    r4 1 14 50
    r5 3 18 50
    r6 7 13 50
    r7 11 13 50
    r8 15 13 50
    r9 3 20 50
    r10 4 5 .43
    r11 8 9 .43
    r12 12 19 .43
    r13 16 30 .5
    l1 5 6 2.1p
    l2 9 10 2.1p
    l3 19 14 2.1p
    l4 30 0 2p
    x1 3 2 4 100 101 count
    x2 7 6 8 200 201 count
    x3 11 10 12 300 301 count
    x4 15 14 16 400 401 count
    *
    * These are the sources which vary
    * In general, the $value1 or $value2 symbols can replace any
    * numerical parameter in the circuit description.  No checking
    * is done as to whether the substitution makes sense.
    *
    *flux bias
    v1 13 0 pulse(0 $value1%m 10p 10p)
    *gate bias
    v2 1 0 pulse(0 $value2%m 10p 10p)
    *
    *
    v3 20 0 pwl(0 0 70p 0
    + 75p  15m 90p  15m 100p -15m 115p -15m 
    + 125p 15m 140p 15m 150p -15m 165p -15m
    + 175p 15m 190p 15m 200p -15m 215p -15m
    + 225p 15m 240p 15m 250p -15m 265p -15m
    + 275p 15m 290p 15m 300p -15m 315p -15m
    + 325p 15m 340p 15m 350p -15m 365p -15m
    + 375p 15m 390p 15m 400p -15m 415p -15m
    + 425p 15m 440p 15m 450p -15m 465p -15m 500p -15m)
    *
    * flux bias first stage
    v4 18 0 pulse(0 13m 10p 10p)
    *gate bias first stage
    v5 17 0 pulse(0 39m 8p 10p)
    *
    *Nb 3000 A/cm2   area = 20 square microns
    .model jj1 jj(rtype=1,cct=1,icon=10m,vg=2.8m,delv=0.08m,
    + icrit=0.6m,r0=49.999998,rn=2.745098,cap=0.777093p)
    .end
\end{verbatim}


%S-----------------------------------------------------------------------------
\section{Atomic Monte Carlo and Range Analysis}
\label{atomic}

% spOpRangeAnal.hlp:atomic 030419

{\bf This is a very new capability under development.}

{\WRspice} provides an interface to the primitive operations used for
operating range and Monte Carlo analysis.  This allows the user to
write scripts to implement custom statistical analysis procedures. 
The scripting is more flexible than the built-in analysis described
elsewhere.


%S-----------------------------------------------------------------------------
\section{Circuit Margin Optimization}

% spOpRangeAnal.hlp:optimize 012709

There are three scripts which implement a margin optimization
algorithm used by Clark Hamilton at NIST.  These files (kept in the
scripts directory) are {\vt optimize}, {\vt margins}, and {\vt merit}. 
The main script is {\vt optimize}, which is invoked with the name of
the file to be optimized as an argument.

This facility is for advanced users.  The present status of the
scripts is unknown, and it is possible that they may require
modification before use.  They are provided as an example of how the
{\WRspice} scripting facility can be employed for optimization.

An example input file, which defines and initializes various variables
and vectors as well as providing a circuit to optimize, is shown
below.  To perform optimization, one gives ``{\vt optimize} {\it
filename}''.

\begin{verbatim}
    .check
    set checkiterate = 3
    let checkN1 = 0
    compose checkPNTS values 1n 2n
    let value[19] = 0
    let flags[19] = 0
    let flags[0] = 1
    let value[0] = .8
    .control
    if (TIME >= checkPNTS[0])
    &#32   checkFAIL = 0
    &#32   if ((abs(v(1)) > 1.5) or (abs(v(1)) < .5))
    &#32       checkFAIL = 1
    &#32   endif
    endif
    .endc
    optimization test
    i1 0 1 pulse(0 1 0 1n)
    r1 1 0 $&value[0]
    .tran .01n 1.1n
    .end
\end{verbatim}

This is the simplest way to input the file, alternatively one could
set the shell variables and vectors externally and/or use a bound
codeblock for pass/fail evaluation.

The {\vt margins} script, called by {\vt optimize} calls the {\et
check} command.  The variable {\vt checkiterate} must be set to a
nonzero value up to 10.  This is the binary search depth for finding
the operating range.

The vectors {\et checkN1} and {\et value} must be defined, {\et
checkN1} is the index into the value array of the variable being
adjusted.  It is altered by the scripts, but it and {\et value} must
be defined before the script is input or in the header as shown.

The vector {\et checkPNTS} is the array of points where analysis is
performed.  Note that due to some strangeness, at least two entries
must exist.

The {\et value} array is initialized to the starting values.  The {\et
flags} vector contains 1 for each entry in the array which is to be
varied, the others are treated as constants.

The lengths of the vectors {\et value} and {\et flags} is 20, which is
assumed in the optimization script.

After the analysis is complete, the {\et value} array will contain the
optimized values.  Two other arrays, {\et lower} and {\et upper}, are
created, and contain the lower and upper limit for each value index.

The scripts provided can be customized by the user for more specific
applications, or used as templates for different types of analysis. 
It is recommended that such scripts be defined as codeblocks to speed
execution.

