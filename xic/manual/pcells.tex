% -----------------------------------------------------------------------------
% Xic Manual
% (C) Copyright 2009, Whiteley Research Inc., Sunnyvale CA
% $Id: pcells.tex,v 1.14 2017/03/22 22:27:01 stevew Exp $
% -----------------------------------------------------------------------------

% -----------------------------------------------------------------------------
\chapter{Parameterized Cells and Vias}

% -----------------------------------------------------------------------------
% xic:pcells 032017
\index{parameterized cells}
\index{template cells}
\section{Parameterized Cells}
\label{pcells}

Parameterized cells, or ``pcells'' (or sometimes called ``template
cells'') are cells which in addition to possible fixed geometry,
contain an executable program that creates geometry according to one
or more parameters supplied to the cell.  The cell is instantiated for
given sets of parameters, so that instances may have layouts that
differ.  Parameterized cells are often used to represent devices such
as MOSFETS that may come in many shapes and flavors.  The MOSFET
parameters select the size and other properties of each instantiation. 
As an alternative, in a process design kit one might find hundreds of
fixed-cells with different permutations of size and other parameters. 
A single parameterized cell that replaces the collection of fixed
cells can streamline the design process, provide greater flexibility,
and reduce errors.

%\ifoa
The full and {\XicII} feature sets have support for native and
OpenAccess-based portable pcells, as well as the ability to work with
the Cadence Virtuoso Express PCells$^{TM}$ feature.  The {\Xiv}
feature set, does not support pcells.

There is an ongoing effort to strengthen the parameterized
cell capabilities in {\Xic}.  The effort includes
\begin{itemize}
\item{Providing support for languages other than the native script
language.  In particular, the Python language appears to be the choice
for ``open'' pcells, i.e., pcells which can be used in tools from
different vendors.}

\item{Provide commonality and support for Ciranova open pcells and
standards.}

\item{Provide commonality and support for the OpenAccess pcell
framework.}
\end{itemize}
%\else
%The full and {\XicII} feature sets have support for native pcells.  The
%{\Xiv} feature set does not support pcells.
%
%Unfortunately, at the present time legal and financial constraints set
%by the controlling organization prevent use of OpenAccess in {\Xic}. 
%With OpenAccess, support for portable pcells, and the ability to work
%with the Cadence Virtuoso Express PCells feature, could be provided. 
%Please contact Whiteley Research if support for OpenAccess would be of
%use to you.  With sufficient demand, the decision to drop OpenAccess
%support may be revisited.
%\fi

\subsection{How PCells Work}
\index{pcell}
\index{super-master}
\index{sub-master}

Provided below are definitions of some terms used frequently in the
discussion that follows.
\begin{description}
\item{\et pcell}\\
A ``parameterized cell'' or ``template cell''.  This is a cell
containing an executable component, which acts on a set of one or more
parameters.  When placed in a layout, the cell constructs itself
according to the parameters given while instantiating.

\item{\et super-master}\\
A {\et pcell} in memory.

\item{\et sub-master}\\
A master cell created from a {\et super-master} and a given parameter
set.  Instances of the sub-master are actually placed into the layout. 
A {\et pcell} itself is never placed in a layout.
\end{description}

All pcells ``work'' as follows.  The pcell is supplied as a cell file
to the design system, which understands the file syntax.  Within the
design system, an in-memory object called a ``super-master'' is
created, which is an in-memory representation of the pcell.  This
element contains a list of parameter names, and for each parameter a
default value and acceptable range.  The element also provides, by
some means, a program or script that can be executed from the design
system.

When a user wishes to place an instance of a pcell, the pcell is
selected from a menu, which causes the pcell file to be read from disk
and a super-master created in memory.  The user will then specify the
parameter values to the cell to instantiate.  This is usually done
with a pop-up form, where the user can enter values for the various
parameters, all of which have defaults.  When this entry is complete,
the design system will execute the pcell script with the entered
parameter values.  The result will be creation of a cell in memory
containing geometry created by the script in accord with the
parameters.  This cell is called a ``sub-master''.  It is a normal
cell is every respect, though it has properties that link it to the
original pcell super-master.  Instances of this sub-master are created
where the user specifies.  A separate sub-master will be created for
every differing parameter set that the user provides.  Each instance
of a sub-master contains properties that contain the parameter set
used for instantiation, and the name of the original pcell.

\index{PCKEEP flag}
A design containing pcells can be saved in two ways.  For a local
save, for use in the same design environment, the super- and
sub-masters in memory are discarded (or the sub-masters may be
cached).  When the design is read in again, the instances provide the
location of the pcell and the parameter set, which are used to
recreate the sub-masters.  If instead the design is being sent to
another environment, one which perhaps does not handle the pcells, the
sub-masters can be written to disk as ordinary cells.  The resulting
hierarchy will be normal and portable.  In {\Xic}, sub-masters can be
included in saved archive files when the {\cb PCellKeepSubMasters}
variable or equivalently the check box in the {\cb Export Control}
panel is set, or when the {\et StripForExport} variable or equivalent
check box in the same panel is set.  If a cell is read from a file and
is recognized as a pcell sub-master, the PCKEEP cell flag will be set. 
This will cause the cell to be written to output, whether or not
writing of pcell sub-masters is enabled.

\subsection{PCell History and Status}

Historically, the pcell concept was developed for the Cadence Virtuoso
layout editor, and supported pcells used the Skill$^{TM}$ language
which is the scripting language of the Virtuoso system.  This remains
the dominant type of pcell around, due to the ubiquity of Cadence
installations.  However, the Skill language is not available outside
of the Cadence environment, so these pcells are not portable to other
tools.

The OpenAccess project addressed the pcell portability problem by
providing a standardized interface for pcells, with the execution
being carried out through a ``plug-in'' that a vendor, or user, may
supply.  A pcell, in concept, can be created to use any suitable
programming language, provided that the tool used to instantiate the
pcell is capable of executing that language.  With OpenAccess, the
portability problem is reduced to obtaining a plug-in for the pcell
language.

There are example plug-ins distributed with OpenAccess that handle Tcl
and C++.  Unfortunately, the Skill language is not available for
general use outside of the Cadence environment.  It is not really
attractive anyway, as it was developed back in the prehistoric days
when Lisp ws ``cool'', and abominations like EDIF seemed important. 
There are far better languages, such as Python, available today.

The concept of portable pcells was championed by a company called
Ciranova, that supplied an OpenAccess plug-in for Python.  They
released this, along with companion applications for Python pcell
(``PyCell'') development, examples, and precompiled OpenAccess and
Python libraries as a free ``PyCell Studio'' download.  Ciranova was
subsequently bought by Synopsys, but the PyCell Studio remains
available and apparently is still under development.  An industry
group, IPLnow.com ({\vt http://www.iplnow.com}) which includes TSMC
and other foundries and some tool vendors, is pushing the cause of
``interoperable'' PDK libraries based on portable pcells.

%\ifoa
{\Xic} is intended to be fully compatible with the PyCell Studio and
PyCells, through the OpenAccess interface plug-in.  In addition,
{\Xic} without OpenAccess provides support for Python pcells, and the
Ciranova protocols for stretch handles and abutment.  However,
Ciranova provides a number of library modules and functions as part of
its Python implementation that are not present without the Ciranova
plug-in and OpenAccess.

{\Xic} with OpenAccess has some limited capability with Skill-based
pcells through the Virtuoso Express PCells feature.  This allows
export is pre-instantiated cached sub-masters of pcells, but not the
pcells themselves.  This capability is provided through the same
OpenAccess plug-in technology mentioned above, but in this case if the
parameter set does not have a pre-built sub-master in cache, the
instantiation will fail.

The {\cb !rmpcprops} command will remove the properties that make
pcells special throughout the hierarchy of the current cell.  This
operation is not undoable, and renders the hierarchy henceforth free
of any pcell history.  The user may wish to do this to hierarchies
imported from Virtuoso, as the Skill pcells can not be evaluated in
the {\Xic} environment.  In this case, retaining the pcell identities
may be pointless, and in fact this may cause trouble, for example when
writing output pcell sub-masters are not written unless the user
overrides the default (e.g., by checking the box in the {\cb Export
Control} panel).
%\else
%Currently, support for OpenAccess pcells is not available.  OpenAccess
%support can easily be provided by paying what amounts to a commercial
%use fee.  Users who may need this feature are encouraged to lobby
%Whiteley Research Inc..
%\fi

\subsection{{\Xic} Native PCells}
\label{pcnative}
\index{native pcell}

{\Xic} supports pcells using the native scripting language, plus
Python or Tcl if the respective plug-ins are loaded.  Parameterized
cells are supported only in physical mode.  This section will describe
how to create and use native pcells in {\Xic}.
%\ifoa
By ``native'', execution within {\Xic} rather than through OpenAccess
is meant.  As will be seen, native pcells can be saved in OpenAccess,
too, and they are still native.
%\fi

There are several example native pcells provided in the examples
directory of the {\it Xic} installation.  These provide samples of the
syntax used in the property strings and other aspects, with comments,
and their study should facilitate understanding how to write native
pcells.

A native pcell can be saved in any format supported by {\Xic}, with
certain limitations to be described.  Probably, the native cell format
is the most convenient.  These can be easily edited with a text
editor, which the advanced developer is likely to do on occasion.

A pcell can have any name that is compatible with {\Xic}.  Earlier
releases of {\Xic} required that a pcell name have a literal ``{\vt
XXX}'' suffix.  This is no longer the case, but if the {\vt XXX} is
present, it will be stripped in sub-master names and replaced with a
unique identifying code for the parameter set.  Otherwise, the code is
appended to the pcell name.

Super- and sub-master cells, and sub-master instances, differ from
normal cells and instances by the presence of a few special
properties.  These are:

\begin{description}
\index{properties!pc\_name}
\index{pc\_name property}
\item{\et pc\_name} property, number 7197\\
This property is assigned by {\Xic} to pcell sub-masters and their
instances.  It provides the name of the pcell from which the
sub-master or instance was derived.

\index{properties!pc\_params}
\index{pc\_params property}
\item{\et pc\_params} property, number 7198\\
This property is assigned by the user to pcells, and contains the
default parameter set.  It will be assigned by {\Xic} to sub-masters
and instances, and contains the parameter set that was used to create
the sub-master.

The string of the {\et pc\_params} property has the form
\begin{quote}
[{\it typechar\/}:]{\it name\/}[{\vt =}]{\it value}[:{\it constraint\/}]
 [[{\vt ,}] ...]  
\end{quote}

The string consists of a series of {\it name} and {\it value} tokens. 
The {\it name}s can not contain white space or punctuation.  Ahead of
the {\it name} is a type specification character if the value is not
string type.  In native pcells, all parameters are (for this purpose)
string type, so the type specifier will never appear.  However, the
syntax used may be extended in future, so it is documented in the
table below.  All types except for string type will have a specifier.
%\ifoa
These {\bf will} appear in property strings obtained from OpenAccess
for non-native pcells.
%\fi

\begin{quote}
\begin{tabular}{ll}\\
\vt b & boolean\\
\vt i & integer\\
\vt t & time value\\
\vt f & 32-bit float\\
\vt d & 64-bit float\\
\end{tabular}
\end{quote}

Each of the {\it name} tokens is the name of a parameter that can be
applied to the pcell.  These will become names of variables in the
script, so that these names should not be defined or used in the
script text in a conflicting way.

Every {\it name} should have a {\it value}, an ``empty'' value is
specified as an empty string ({\vt ""}).  The {\it value} is separated
from the {\it name} by white space, a comma, or an equal sign.  The
{\it values} are taken as default values for the parameters, and can
be numeric values or strings.  A {\it value} that contains white
space, commas, or colons should be quoted.  The value string can also
be an executable code fragment using only parameters already defined
(to the left) and constants, for example

\begin{quote} \vt
param1=2,param2="param1 + 1"
\end{quote}

This form, however, can not be used with constraints (see below).  It
can also only appear in super-master {\et pc\_params} properties.  the
{\et pc\_params} strings of sub-masters and instances must have
constant values.

The quoting behavior is a bit complicated, so as to support Python and
native languages.  If the {\it value} is quoted with double-quote
marks, the double quote marks will be stripped, and the parameter will
take the enclosed characters.  However, if a backslash character
(`$\backslash$') appears ahead of the first double quote, the double
quote marks will be retained.  In the native language, this will
ensure that the parameter is string-type.

For example
\begin{quote} \vt
myvar="123"
\end{quote}
The parameter (variable) {\vt myvar} will be assigned the value 123,
causing it to become scalar-type.  On the other hand
\begin{quote} \vt
myvar=$\backslash$"123"
\end{quote}
will assign {\vt "123"} to {\vt myvar} (including the quotes) thus
{\vt myvar} will be string-type.  In general, if the {\it value} is to
be taken as a string constant in the native language, a backslash
should be placed ahead of the first double quote mark.

If the {\it value} is quoted with single-quote marks, the single-quote
marks are retained, along with the characters between them.  This is
for Python support.  However, if the second character is a
double-quote mark, the single-quote marks will be stripped, leaving
the double-quoted result.  This is an alternative and somewhat
deprecated way to specify a string constant in the native language.

\begin{quote} \vt
mystring='"a string constant"'
\end{quote}

In any case, when the parser is searching for the ending quote mark
(single or double), if the mark is found but it is preceded by a
backslash, both characters are taken verbatim and the search
continues.  Thus, the backslash can be used to hide quote marks of the
same type in the string.

If the {\it value} is a constant (not an executable fragment), the
{\it value} can be followed by an optional constraint specification,
separated from the {\it value} by a colon (no white space is allowed
around the colon).  Constraints define the scceptable values for the
parameter, using a syntax described in \ref{constraints}.  The
constraints appear only in {\et pc\_params} properties of
super-masters, and are not copied to {\et pc\_params} properties of
sub-masters and instances.

The parameter string is logically converted to a series of assignment
statements which are executed before the script.  For example, the
parameter string
\begin{quote}
\vt param1=1.0,name=$\backslash$"my template",param2="param1 * 2"
\end{quote}
would map to the following logical script lines
\begin{quote} \vt
param1 = 1.0\\
name = "my template"\\
param2 = param1 * 2
\end{quote}

\index{pc\_script property}
\index{properties!pc\_script}
\item{\et pc\_script} property, number 7199\\
This property is assigned by the user to a pcell, and appears only in
the super-master.  It contains the script, or a path to a script,
which is executed when the pcell is instantiated.

The {\et pc\_script} property text is in the form
\begin{quote}
[{\vt @LANG} {\it langtok\/}] {\vt @READ} {\it path}
 [{\vt @MD5} {\it digest\/}] {\vt |} {\it script text}
\end{quote}
 
The {\vt @LANG}, {\vt @READ}, and {\vt @MD5} tokens are literal.  The
{\it langtok} may be one of (case insensitive)
\begin{quote}
\begin{tabular}{ll}\\
{\vt n}[{\vt ative}] & native sript, the default\\
{\vt p}[{\vt ython}] & python script\\
{\vt t}[{\vt cl}] & tcl script\\
\end{tabular}
\end{quote}
 
The {\it path} token must appear if {\vt @READ} is given.  If {\vt
@READ} is not given, any remaining text is taken as literal executable
script text.

The {\it path} is to a file containing the executable text, and should
be quoted if it contains white space.  If the {\it path} is not
rooted, it will be searched for in a directory search path set in the
{\et PCellScriptPath} variable.

When a path is given, one can also apply the {\vt @MD5} {\it digest}
clause.  The {\it digest} is that for the script file, and can be
obtained from the {\cb !md5} command, or the {\vt Md5Digest} script
function, or from the command
\begin{quote}
{\vt openssl dgst -md5} {\it filepath}
\end{quote}
on most Linux systems.  If given, the script file digest must match
the digest given, or the script will not be executed.  This will
ensure that only the ``correct'' script file is used.
\end{description}

Previous versions of {\Xic} required that the script actually appear
in the {\et pc\_script} property string.  This can still be done, and
may be convenient for many pcells, particularly very simple ones. 
However, one may encounter a portability issue caused by string length
limitations of the GDSII and CGX formats due to their maximum record
length of 64KB.  The native cell format, the CIF format as extended by
Whiteley Research, and the OASIS format have no built-in string length
%\ifoa
limit, nor does OpenAccess.
%\else
%limit.
%\fi

When using separate script files, for portability it may be best to
{\bf not} provide a full path to the script in the {\et pc\_script}
property string, but give the file name only and use the search path
variable.  Then, the scripts can be kept in different locations at
different {\Xic} installations, and pcells will still be portable
provided the {\et PCellScriptPath} is set (probably from an
initialization file).  The {\vt MD5} digest keying can ensure that the
script file found via the search path is correct, or it will not
execute.

The script, whether in a separate file or not, is basically
conventional, and uses the native object creation functions to build
up the geometry, presumably using the parameter values as input.  The
example native pcells provided with the {\Xic} distributions in the
examples directory illustrate how the script is incorporated.

One aspect of importance is the script return value, which will tell
the calling program whether or not script evaluation succeeded.  If
evaluation fails, {\Xic} can gracefully ``clean up'' by destroying
partially completed sub-masters, and any corresponding instance
placements, and alerting the user to the error.

The script should return 0 (zero) on success, which is the default if
no explicit return value is specified.  Any nonzero return value
indicates faliure.  The mechanics of setting the return value differs
between the supported languages, and is described below.  In every
case, just before a nonzero value is returned, the {\vt AddError}
function should be called with a message explaining the error.

\begin{description}
\item{Native}\\
The {\vt return} keyword, followed by a value, will terminate the scrpt
and return the value.  For example, here is a snippet that checks the
value of a parameter named ``{\vt top}'' and fails if it is out of range:
\begin{quote} \vt
if (top < 1 | top > 20)\\
\hspace*{5mm}AddError("Parameter top is out of range [1 - 20].")\\
\hspace*{5mm}return 1\\
end
\end{quote}

Actually, if the value following {\vt return} is omitted, the return
value is 1, so just a bare ``{\vt return}'' will signal the error
condition.  If the end of execution is reached and no {\vt return}
keyword is encountered, the value returned is 0 (success).  If the
script is terminated with the {\vt Halt} or {\vt Exit} functions, the
return value is 0.  If the script is halted by an internal error, the
return value is -1.  If the script is halted due to an interrupt
signal, the return value is 1.

\item{Python}\\
The recommended way to induce an error exit in a Python script is to
call ``{\vt sys.exit}'' with a nonzero argument.  The example above
translated to Python will read:
\begin{quote} \vt
if (top < 1 or top > 20):\\
\hspace*{5mm}xic.AddError("Parameter top is out of range [1 - 20].")\\
\hspace*{5mm}sys.exit(1)
\end{quote}

Errors detected by the Python interpreter are passed back as nonzero
exit returns.

\item{Tcl}\\
The recommended way to induce an error exit from a Tcl script is to
call ``{\vt return -code error}''.  The example above translated to
Tcl will read:
\begin{quote} \vt
if \{\$top < 1 || \$top > 20\} \{\\
\hspace*{5mm}AddError \{"Parameter top is out of range [1 - 20]."\}\\
\hspace*{5mm}return -code error\\
\}
\end{quote}

Errors detected by the Tcl interpreter are passed back as nonzero exit
returns.
\end{description}

To summarize, a pcell is never itself instantiated.  When one
places an instance of a pcell, the following steps occur:

\begin{enumerate}
\item{The pcell is read into memory as a ``super-master'' if it
is not already there.}

\item{The user enters the parameter values.}

\item{The database is searched for another cell derived from the same
pcell with the same parameter values, i.e., an equivalent sub-master. 
If one is found, a new instance is created and given {\et pc\_name}
and {\et pc\_params} properties copied from the sub-master, and we're
done.}

\item{Otherwise, the script is executed, in the context of a new,
empty cell whose name consists of the pcell name suffixed by a unique
identifier.  This is the sub-master cell.  It is given a {\et
pc\_name} property to identify the pcell, and a {\et pc\_params}
property to list the parameters used.  The new sub-master is
instantiated and the instance given the same two properties, and we're
done.}
\end{enumerate}

Once the instance is placed, it behaves in all respects as a normal
cell.  It has a ``master'' derived from the pcell as a sub-master, and
a unique sub-master exists for each unique parameter set.  Writing the
hierarchy, including the sub-masters, to an archive produces a
perfectly normal file.  However, by default the sub-masters are {\bf
not} written to output, instead they are expected to be recreated from
the pcell when needed.  The pcells (super-masters) are {\bf never}
included in the output file, since they are not directly instantiated
in the hierarchy.  Thus, when exporting, the pcell should be supplied
separately, if needed.  If sub-masters are included in the archive,
then the pcell is not needed, unless further parameter changes are
required.  In {\Xic}, sub-masters can be included in saved archive
files when the {\et PCellKeepSubMasters} variable or equivalently the
check box in the {\cb Export Control} panel is set, or when the
{\et StripForExport} variable or equivalent check box in the same
panel is set.

\subsection{Creation of a Native Parameterized Cell}

To create a native pcell, one can follow this procedure:

\begin{description}
\item{\bf Write the script}\\
Write a script that creates the geometry desired, in response
to a set of variables that will become the parameters.  The script
can be authored as any other script.  It should be thoroughly
debugged before committing it to a parameterized cell.

It is recommended that the top of the script contain a comment listing
the parameters and their purposes, and explicit tests of the values
that will abort the script (returning nonzero) if a value is out of
range or otherwise not acceptable.  Any nonzero return should have a
call to {\vt AddError} explaining the error.  This text will be
included in the system error reporting.

\item{\bf Create the parameterized cell}\\
Use the {\cb Open} ({\cb File menu}) command to edit a new cell which
will become the pcell.  Add any fixed geometry to the cell that is
necessary.  This can be done at any time.  Keep this cell as the
current cell and add the properties listed below.

\item{\bf Add the {\et pc\_script} property}\\
Bring up the {\cb Cell Property Editor} ({\cb Edit Menu}).  Press {\cb
Add}, which brings up a pop-up menu, and select {\cb pc\_script} in
the pop-up menu.  This will prompt for the property string on the
prompt line.

At this point we need to decide whether to incorporate the script
into the property string itself, or to keep the script in a separate
file.  One consideration is that GDSII and CGX files have 16-bit record
lengths, which will limit the lengths of property strings.  In the
present {\Xic} release, CIF and native string lengths, and
OASIS string lengths, are unlimited.
%\ifoa
There is also no limit when storing the cell in OpenAccess.
%\fi

First, assume that the script is to be stored in the property string. 
We will use the ``long text'' feature to facilitate entering the
script.

\item{\bf Enter property text with script}\\
Press the ``{\cb L}'' button to the left of the prompt line.  This
brings up the {\cb Text Editor} pop-up.  If the script text is Python
or Tcl, a {\vt @LANG} specification must appear first.  Type one of
the following into the editor window.  For Python
\begin{quote}
\vt @LANG Python
\end{quote}
or if Tcl
\begin{quote}
\vt @LANG Tcl
\end{quote}
Neither is needed for native script language.

The next step is to import the script text.  This is presumed to exist
in a file, though for very simple scripts an advanced user can type it
in.  For the script in a file, one can use the {\cb Read} button of
the text editor (in the {\cb File} menu) to read in the script file. 
Then perform any last minute editing, such as removal of the variable
declarations that would be redundant with the parameters.

Press the {\cb Save} button in the {\cb File} menu of the text editor. 
The text editor will disappear, and the script will have been saved in
the {\et pc\_script} property of the current cell.

\item{\bf Enter property text without script}\\
One can use the ``long text'' text editor feature, or simply type into
the prompt line.  Without the script, there generally isn't much to
type.

First, if the script text is Python or Tcl, one must enter a {\vt
@LANG} specifier as explained above.  If needed, just type in the two
tokens.  Next, enter a {\vt @READ} directive in the form
\begin{quote}
{\vt @READ} {\it path}
\end{quote}
where {\it path} is a path to the file containing the script.  This
can be an absolute path, however it may be more convenient to just
specify the file name, and set the {\et PCellScriptPath} variable to a
directory where pcell script files are kept.  Then, the location can
change without one having to edit the property string.  This completes
text entry.  Exit the text editor as above if it is being used, or
press {\kb Enter} to terminate text entry into the prompt line.  The
text is saved in the {\et pc\_script} property of the current cell.

Optionally, one can append a directive of the form
\begin{quote}
{\vt @MD5} {\it digest}
\end{quote}
The {\it digest} is the 32-character string obtained from the {\cb
!md5} command for the script file.  When included, the script will not
execute unless the script file has a matching MD5 digest, which
ensures that the script file accessed is the correct one and hasn't
been modified.

\item{\bf Add a {\et pc\_params} property}\\
Next, we program the pcell's parameters and default values by adding a
{\et pc\_params} property.  In the {\cb Cell Property Editor} ({\cb
Edit Menu}), press {\cb Add}, then select {\cb pc\_params} in the
pop-up menu.

Again, one can use the ``long text'' editor, or type directly into the
prompt line.  For long parameter lists, the editor would be preferred. 
Enter the parameter list in the format described for this property
string (see \ref{pcnative}).  If using the editor, any combination of
multiple lines and/or multiple specifications per line can be used.  A
parameter specification consists of a parameter name followed by `{\vt
=}' and its value, optionally followed by a colon and a constraint
string (see \ref{constraints}).  There must be no white space around
the colon that delimits the constraint string, but the constraint
string itself may contain white space, which is ignored.

Save the text if using the text editor, or press {\kb Enter} if using
the prompt line, when done.

\item{\bf Add additional properties}\\
There are other properties that may be required, to support stretch
handles (draggable edges, see \ref{pcstretch}) and auto-abutment (see
\ref{pcabut}) protocols.  Text is added as for the properties we've
described.  This may be a second pass, after getting the basic cell
working.
\end{description}

Save the current cell to disk, the native format is probably
most convenient.  Congratulations, you have yourself a pcell!

\subsection{Adding an Instance of a Parameterized Cell}

Adding a pcell to the current layout is the same procedure, whether
the pcell is native, or not.  One adds an instance of a pcell like one
would add an instance of any other cell.  If a native pcell, the cell
file name can be given to the {\cb New} text entry pop-up of the {\cb
Cell Placement Control} panel brought up with the {\cb place} button
in the side menu.

%\ifoa
Pcells saved in OpenAccess can be instantiated with the {\cb Place}
button in the {\cb Contents} listing window from the {\cb OpenAccess
Libraries} pop-up from the {\cb File Menu}.  These cells are also
available through the {\cb Cell Placement Control} panel.  In the text
input pop-up from the {\cb New} button, enter the OpenAccess library
name that contains the desired pcell, followed by space, then the
pcell name.
%\fi

When cell placement becomes active, by pressing the {\cb Place} button
the {\cb Cell Placement Control} panel, the {\cb Parameters} pop-up
appears.  This pop-up displays a text entry area for every parameter,
loaded with the default value.  The user can enter the values desired.

In addition, a double-line box is ghost-drawn and attached to the
mouse pointer.  This figure does {\bf not} represent the actual size
of the instance, in fact it illustrates that the instance size is
unknown.  The instance size will not be known until the parameter set
is used to create or identify the corresponding sub-master cell.  This
will happen when the user clicks in the drawing window to place an
instance.  Better, the {\cb Apply} button in the {\cb Parameters}
pop-up can be pressed, which will create a sub-master without instance
placement.  The box attached to the mouse pointer will now be formed
with a single line, and will have the actual size.

As with a normal cell, instances are placed where the user clicks. 
Note that the {\cb Parameters} pop-up remains visible while instances
are being placed.  The parameters can be changed, and the {\cb Apply}
button pressed, to change the type of instantiation to be subsequently
placed.  Note that the subsequent instances will use the new parameter
values, pressing {\cb Apply} merely updates the bounding box attached
to the mouse pointer.

\subsection{Changing the Parameters of an Instance}

Once a pcell has been instantiated, the instance can be changed to
represent a new set of parameter values {\bf if} the pcell is
available.  Thus, when a design is exported to another site that may
wish to modify the cell parameters, the pcells must be exported as
well.  The pcells are {\bf not} automatically added to GDSII files or
the other file formats.  They can be supplied as {\Xic} cells, in
addition to the GDSII or other output.  Further, {\Xic} native pcells
are {\bf not} directly portable to other design systems, they are
known to {\Xic} only.

One possible way to maintain native pcells is to place them
in a library.

Assuming that the pcell is available, one can change the parameters of
an existing pcell instance with the following procedure.  First,
select the pcell instance to modify.  Then, while holding down the
{\kb Ctrl} key, click on the selected pcell.  The {\cb Parameters}
panel will appear.  One can now change parameter values as needed, and
press {\cb Apply} to reparameterize the instance.

Less conveniently, the {\et pc\_params} property can be edited with
the {\cb Property Editor} with the same effect.  Bring up the {\cb
Property Editor} with the {\cb Properties} button in the {\cb Edit
Menu}.  With the editor active, click on a pcell instance.  The
instance will be marked, and its properties listed.  Among the listed
properties will be the {\et pc\_params}.  Click on this entry in the
listing window, the text will show as selected.  Then, press the {\cb
Edit} button in the {\cb Property Editor}, which will bring up our old
friend the {\cb Parameters} panel.  Adjust the parameters, then press
{\cb Apply}.  The new parameter set will be applied to the marked
instance.

\subsection{Changing the Parameters of a Sub-Master}

One can change all of the instances that use a particular parameter
set to a new parameter set by changing the parameters of the
sub-master cell of the instances.  The original pcell must be
accessible, as for changing individual instances.  The procedure is to
edit the parameters of a sub-master, which will have the effect of
reparameterizing all of its instances.

A quick way to do this is to select an instance of the sub-master to
be edited, and press the {\cb Push} button in the {\cb Cells Menu}. 
The editing context will be pushed to the sub-master.  The sub-master
can also be selected for editing from the {\cb Cells Listing} pop-up
({\cb Cells Menu}), or by giving its name in the {\cb Open} command
({\cb File menu}).

With the sub-master as the current cell, bring up the {\cb Cell
Property Editor} with the {\cb Cell Properties} button in the {\cb
Edit Menu}.  The listing of properties will include a line for the
{\et pc\_params} property.  Select the property by clicking on it,
then press the {\cb Edit} button.  Again, the {\cb Parameters} pop-up
will appear.  One should modify the parameters desired, then press
{\cb Apply}.  The new parameter set will then apply to the instance
pushed into, and all other instances of the same sub-master.  Use the
{\cb Pop} button in the {\cb Cells Menu} to return to the original
editing context if {\cb Push} was used.

% -----------------------------------------------------------------------------
% constraints 102214
\section{Parameter Constraints}
\label{constraints}
\index{parameter constraints}

Constraints are described by text strings included in the {\et
pc\_params} property contained in the super-master cell.  Constraints
do not appear in the sub-master or instance properties.
%\ifoa
Constraint support is also provided for Ciranove/Python OpenAccess
pcells, though the constraint strings are provided by another method
internally as there are no corresponding super-master {\Xic} cells.
%\fi

In {\Xic}, constraints are mainly handled in the {\cb Parameters}
panel (see \ref{pcparams}), which is where parameter setting is
primarily handled.  The constraints may affect the type of input
widget for the parameter.  It will not be possible to set a value for
the parameter that is not allowed by the associated constraint.

The constraint strings follow closely the Ciranova format.  Each is in
the form of a Python function call, with a set of arguments that
define the constraint.  The arguments can be either positional or
named.  For example, the {\vt range} constraint has the following
template:

\begin{quote}
{\vt range(}{\it low\/},{\it high\/},{\it resolution\/}={\vt None},{\it
 action\/}={\vt REJECT)}
\end{quote}

The two final arguments have defaults, and are therefor optional. 
Arguments can be given positionally, or as an assignment using the
argument name keyword.  The following forms are equivalent:

\begin{quote} \vt
range(0,10)\\
range(high=10,low=0)
\end{quote}

The first line follows the argument order of the template.  The second
line does not, but supplies the argument name explicitly.  Arguments
can appear in any order if the name is given.  An argument list can
use both positional and explicit assignment.  Note that the {\it
resolution} and {\it action} arguments are not given in either
example, so that the defaults will be used.

All keywords are case-insensitive.

Each constraint type contains an {\it action} argument, which can be
set to one of the literal enumerators {\vt REJECT}, {\vt ACCEPT}, or
{\vt USE\_DEFAULT}.  This specifies what happens when an attempt is
made to set the parameter to a value not allowed by the constraint. 
The {\vt REJECT} option (the default) will simply fail, causing the
command that initiated the operation to also fail.  The {\vt ACCEPT}
action will accept the new parameter value, basically ignoring the
constraint.  The {\vt USE\_DEFAULT} option is intended to reset the
parameter to the default value when the constraint test fails, but
this is not implemented in {\Xic}, {\vt REJECT} will be done instead.

The enumeration value {\vt None} can be given to most arguments.  This
usually means to ignore the argument, and skip any test that would use
the argument.  For example, a range constraint may give a {\it high}
value of {\vt None}, meaning that the parameter value can be
arbitrarily large.

The available constraint types are as follows.

\begin{description}
\item{\vt choice}\\
\index{choice constraint}
The {\vt choice} constraint restricts the parameter to a number of
alternatives.  These alternatives can be numbers or strings, as
appropriate for the parameter data type.  The keyword ``{\vt
choiceConstraint}'' is a (case-insensitive) synonym.  The template is

\begin{quote}
{\vt choice(}{\it choices\/},{\it action\/}={\vt REJECT)}
\end{quote}

where the {\it choices} argument is a list in the form

\begin{quote}
{\vt [}{\it element\/},{\it element\/}...{\vt ]}
\end{quote}

The square brackets are literal, {\it elements} are numbers or strings
(single or double-quoted) which are separated by commas.

Examples:\\
{\vt choice([1,2,4,8])}\\
{\vt choice(["red","green","blue"])}

The first line restricts the numeric parameter to the values listed. 
The second line would restrict a string parameter to the strings
listed.  Note that if the script is Python, single quotes must be used
instead of double quotes.  Single or double quotes can be used with
native scripts.

\item{\vt range}\\
\index{range constraint}
The {\vt ramge} constraint restricts a numerical parameter to a
range of values.  The keyword ``{\vt rangeConstraint}''
(case-insensitive) is a synonym.  The template is

\begin{quote}
{\vt range(}{\it low\/},{\it high\/},{\it resolution\/}={\vt None},{\it
 action\/}={\vt REJECT)}
\end{quote}

The {\it low} and {\it high} are numerical endpoints of the range. 
Either can be the enumeration value {\vt None}, which skips testing
against that endpoint.  For example,

\begin{quote}
{\vt range(0,None)}
\end{quote}

simply indicates that the value must be zero or larger.

The numerical values passed for {\it low} and {\it high} must be
consistent with the language used for the script.  In particular,
Python requires a standard integer or floating-point format.  The
native language allows SPICE-type numbers (e.g., {\vt 1.2K}), hex
numbers with a ``{\vt 0x}'' prefix (e.g., {\vt 0xff00}) and character
constants (e.g., {\vt '$\backslash$n'}) in addition.

The {\it resolution} argument is used in the {\cb Parameters} panel to
set the number of digits to include following a decimal point (see
\ref{pcparams}).

\item{\vt step}\\
\index{step constraint}
The {\vt step} constraint limits the numerical parameter value to
multiples of a given delta between a starting and ending value.  The
keyword ``{\vt stepConstraint}'' (case-insensitive) is a synonym.  The
template is

\begin{quote}
{\vt step(}{\it step\/},{\it start\/}={\vt 0},{\it limit\/}={\vt
 None},{\it resolution\/}={\vt None},{\it action\/}={\vt REJECT)}
\end{quote}

The parameter must be numeric.  If the {\it step} value is 0 or {\vt
None}, the constraint acts the same as the {\vt range} constraint,
with {\it start} and {\it limit} providing the low and high values,
respectively.

Otherwise, the allowed values are given by

\begin{quote}
{\it start} {\vt + N*}{\it step}
\end{quote}

where {\vt N} is a non-negative integer, and the value of the
expression is within the range terminated by {\it limit\/}, if {\it
limit} is not {\vt None}.  Note that {\it step} can be negative, in
which case the parameter value must be greater than or equal to {\it
limit\/}.

The {\it resolution} is treated as in the {\vt range} constraint.

\item{\vt numericStep}\\
\index{numericStep constraint}
This is very much like the {\vt step} constraint, but is intended for
use with string variables used for numeric input to support SPICE-like
multipliers.  This is needed for script languages that don't handle
numbers in this format.  Since the native script language understands
this number format directly, it is not clear that the {\vt
numericStep} constraint will ever be needed in pcells with native
scripts.  The keyword ``{\vt numericStepConstraint}'' is a synonym. 
The template is

\begin{quote}
{\vt step(}{\it step\/},{\it start\/}={\vt 0},{\it limit\/}={\vt
 None},{\it resolution\/}={\vt None},{\it scaleFactor\/}={\vt
 'u'},{\it action\/}={\vt REJECT)}
\end{quote}

The arguments are the same as for the {\vt step} constraint, with the
addition of {\it scaleFactor\/}.  The {\it scaleFactor} is a string
set to one of the scaling suffixes from the table below:

\begin{quote}
\begin{tabular}{|l|l|l|} \hline
\bf suffix & \bf multiplier & \bf name\\ \hline\hline
\vt a & \vt 1e-18 & \vt atto\\ \hline
\vt f & \vt 1e-15 & \vt femto\\ \hline
\vt p & \vt 1e-12 & \vt pico\\ \hline
\vt n & \vt 1e-9 & \vt nano\\ \hline
\vt u & \vt 1e-6 & \vt micro\\ \hline
\vt m & \vt 1e-3 & \vt milli\\ \hline
\vt mil & \vt 25.4 & \vt mil\\ \hline
\vt k & \vt 1e3 & \vt kilo\\ \hline
\vt meg & \vt 1e6 & \vt mega\\ \hline
\vt g & \vt 1e9 & \vt giga\\ \hline
\vt t & \vt 1e12 & \vt tera\\ \hline
\end{tabular}
\end{quote}

The scale fastor is case-insensitive.  If the {\it scaleFactor} is
assigned the value {\vt None}, no scale fastor is assumed, and the
constraint is basically identical to {\vt step}.  If a scale factor is
given, numbers given for {\it step\/}, {\it start\/}, and {\it limit}
are internally multiplied by the scale factor, before comparison to
the parameter value.
\end{description}

% -----------------------------------------------------------------------------
% xic:pcparams 020615
\section{Parameters Panel:  Set PCell Parameters}
\label{pcparams}
\index{Parameters panel}
\index{parameter entry}

The {\cb Parameters} panel appears when it is necessary to provide
parameters for a parameterized cell (pcell) instantiation.  These
situations include

\begin{itemize}
\item{During placement of pcell instances with the {\cb Cell Placement
Control} panel from the {\cb place} button in the side menu.}

\item{While editing a {\et pc\_params} instance property with the {\cb
Property Editor}, which is obtained with the {\cb Properties} button
in the {\cb Edit Menu}.}

\item{If the user clicks with button 1 and the {\kb Ctrl} key held on
a selected pcell instance, The {\cb Parameters} panel will appear. 
The user can reparameterize the instance.}

\item{While editing the {\et pc\_params} property of the current cell
with the {\cb Cell Property Editor}, which is obtained with the {\cb
Cell Properties} button in the {\cb Edit Menu}.}

\item{If one opens a non-native pcell for editing, the {\cb
Parameters} panel will appear.  In this case, the label on the
leftmost button is ``{\cb Open}'' rather than ``{\cb Apply}''. 
Entering parameters then pressing {\cb Open} will create or find the
sub-master for the parameter set, and make it the current cell.  This
will not happen with native pcells, which can be edited directly in
{\Xic}.}
\end{itemize}

The {\cb Parameters} panel provides an entry area for each pcell
parameter.  In cases where there more parameters than will fit within
the window, a scroll bar will appear, allowing the user to scroll the
parameter listing.  The listing order of the parameters is as provided
by the pcell.

The type of entry widget shown in the panel depends on the data type
of the parameter, and the parameter constraint specification.  The
constraint string, if any, is obtained from the {\et pc\_params}
property of the pcell super-master.  The following logic is used:

\begin{itemize}
\item{If the parameter is boolean, any constraint is ignored, and a
check box is created.}

\item{If the parameter has a {\vt choice} constraint, a drop-down
menu containing the given choices is created.  The choices can be
numeric or string values.}

\item{If the parameter has a {\vt range} or {\vt step}
constraint, a numeric entry ``spin'' button is created.  The numbers
displayed in the text area follow the constraint, i.e., the range is
limited, and the step value (if any) is enforced.  The up/down arrows
add or subtract a step value.  Further, the floating-point precision
used for the number will follow the {\it resolution} value of the
constraint.  This is described below.}

\item{If the parameter has a {\vt numericStep} constraint, the
set-up is very similar to the {\vt step} constraint, but an additional
label will appear showing the {\it scaleFactor\/}, if any.  This scale
factor is logically appeaded to the number that appears in the entry
area.}

\item{If there is no constraint, a simple text-entry area is created.}
\end{itemize}

For numeric entries, the constraint {\it resolution} value will set
the number of digits that follow the decimal point in the display. 
For the default value of {\vt None}, or if less than 1.0, the number
of digits will be based on the current database resolution, as set at
program startup with the {\et DatabaseResolution} variable.  If the
resolution is the default value of 1000, three digits will be used
({\vt 1.235}), otherwise four ({\vt 1.2345}).

Otherwise, the number of digits following the decimal will be set
by the following logic:
\begin{quote} \vt
    if (resol > 1e5)  num = 6\\
    else if (resol > 1e4)  num = 5\\
    else if (resol > 1e3)  num = 4\\
    else if (resol > 1e2)  num = 3\\
    else if (resol > 1e1)  num = 2\\
    else if (resol > 1e0)  num = 1\\
    else num = 0
\end{quote}

Note that giving a {\it resolution} of 1.0 will set the number of
digits to zero, indicating integer values only (no decimal point is
shown in this case).

The panel logic differs somewhat depending on the context.  When
editing an existing property, with the {\cb Property Editor} or {\cb
Cell Property Editor}, the {\cb Parameters} panel is ``modal'',
meaning that the rest of {\Xic} is inactive while the panel is
visible.  The user is expected to enter the appropriate parameter data
and either press {\cb Apply} which will accept the new parameter set,
or {\cb Dismiss}, which will abort the current parameter edit.  In
both cases, the {\cb Parameters} panel will disappear, and {\Xic} will
return to normal status.  The {\cb Reset} button will revert all
parameter settings in the panel to the initial settings when the panel
was created, i.e., the values from the existing property string.

When placing instances, on the other hand, the {\cb Parameters} panel
is not modal.  The parameters can be changed at any time, and the
changed parameter set will apply when new instances are created,
whether or not {\cb Apply} is pressed.  Pressing {\cb Apply} will
create or find the existing sub-master for the parameter set, from
which the instance bounding box is obtained and used in the
ghost-highlighting during instance creation.  The {\cb Dismiss} button
will remove the panel, but the instance placement will continue.  The
{\cb Reset} button will reset all parameter values displayed in the
panel to the defaults provided in the pcell.

When opening a foreign pcell, the {\cb Parameters} panel is non-model,
and nothing happens unless/until {\cb Open} is pressed.  Pressing {\cb
Open} will create a new sub-master if necessary for the parameters as
set, and make the sub-master the current cell for editing.  Editing
the sub-master is generally not a great idea, unless the user
understands the issues.  Changing the {\et pc\_params} property,
though, is a valid way to modify all instances of the master.  Other
changes to the sub-master will be lost, unless the sub-master is
saved, possibly with the {\et PCellKeepSubMasters} variable set. 
Pressing {\cb Dismiss} simply retires the panel.  Pressing {\cb Reset}
returns all parameter values shown in the panel to the pcell default
values.


% -----------------------------------------------------------------------------
% pc_stretch 111919
\section{PCell Stretch Handles}
\label{pcstretch}
\index{stretch handles}
\index{grip}

{\Xic} supports the protocol for stretch handles defined by Ciranova. 
This provides support for stretch handles defined in PyCells, but also
allows use of stretch handles in native pcells.

A stretch handle is a graphical item that can be moved with the mouse
pointer, where the motion causes a change in a parameter value. 
Usually, the object is associated with a parameterized cell
instantiation, and motion causes remastering of the instance to a new
sub-master created with the new parameter.  For example, stretch
handles might be used to graphically change the gate length and width
of a MOSFET pcell instance, if the corresponding pcell supports the
protocol.

Stretch handles are visible and activated only when the containing
instance is shown large enough on-screen, to avoid false-triggering. 
The size threshold can be set from the {\cb PCell Control} panel from
the {\cb Edit Menu}, or equivalently with the {\et PCellGripInstSize}
variable.

In {\Xic}, when editing a sub-master containing stretch handles, the
handles are visible as well, and can be moved.  This will change the
parameterization of the sub-master, and all of its instances.  This is
equivalent to modifying the {\et pc\_params} property with the {\cb
Cell Property Editor} from the {\cb Edit Menu}.

If the {\cb Hide and disable stretch handles} check box in the {\cb
PCell Control} panel from the {\cb Edit Menu} is checked, or
equivalently if the {\et PCellHideGrips} variable is set, all stretch
handles will be invisible and disabled.

Adding stretch handles to a pcell amounts to adding box objects with
the {\et grip} property applied.  The {\et grip} property provides the
setup information.

There are example capacitor pcells that use stretch handles that can
be found in the examples directory of the {\Xic} program distribution
area.  These demonstrate use of stretch handles and illustrate the
property syntax.

\begin{description}
\index{grip property}
\index{properties!grip}
\item{\et grip} property, number 7195\\
This property is very similar to the Ciranova {\et pycStretch}
property, used to implement stretch handles.  The property has meaning
when applied to physical-mode boxes only.  The property string has the
following format:

\begin{quote}
{\vt name:}{\it val}{\vt ; stretchType:}{\it val\/}{\vt ,
direction:}{\it val\/}{\vt , parameter:}{\it val\/}{\vt ,
minVal:}{\it val\/}{\vt , maxVal:}{\it val\/}{\vt ,
location:}{\it val\/}{\vt , userScale:}{\it val}{\vt ,
userSnap:}{\it val\/}{\vt , key:}{\it val}
\end{quote}

The terms have precisely the same names and interpretation as the {\et
pycStretch} property described in the {\it Ciranova PyCell EDA Tool
Integration Guidelines} document provided with the Ciranova PyCell
Studio package (now available from Synopsys).  However, there are some
differences.

\begin{enumerate}
\item{Ciranova does not allow white space within the string.  In
{\Xic}, white space can appear between the terms as shown above.}

\item{The semicolon following the name and the commas are optional,
the terms can be white-space separated.}

\item{In both cases a property string can contain multiple grip
specifications.  Ciranova separates the specifications by white space. 
In {\Xic}, a new specification is started whenever a keyword is
repeated.}

\item{Ciranova requires that all keywords be provided in each
specification, except for the name, which can be omitted for names
with varying {\vt key} strings.  In {\Xic}, when parsing multiple
specifications, previous values of the various parameters are
retained, so only changed values need be given.}

\item{{\Xic} keyword matching is case-insensitive.}
\end{enumerate}

The terms have the following significance.
\begin{description}
\item{\vt name}\\
A name for the stretch handle, which should be a unique string token
within the pcell.

\item{\vt stretchType}\\
Set to one of the keywords `{\vt relative}'' or ``{\vt absolute}''. 
Per Ciranova, if {\vt relative}, the increment is measured relative to
the center of the rectangle, while {\vt absolute} is the increment
measured according to the absolute X and Y directions.  This parameter
is ignored in {\it Xic}, since the explanation does not seem to make
sense.

\item{\vt direction}\\
Set to one of the keywords ``{\vt NORTH\_SOUTH}'' or ``{\vt
EAST\_WEST}'', specifying the translation direction of the stretch
handle.

\item{\vt parameter}\\
The name of the pcell parameter that is modified by the stretch
handle.

\item{\vt minVal}\\
A numerical value giving the minimum value of the parameter being
modified.  SPICE-style scaling suffix values and units, e.g., {\vt
1K}, {\vt 100nM}, are acceptable, units are ignored.

\item{\vt maxVal}\\
A numerical value giving the maximum value of the parameter being
modified.

\item{\vt location}\\
This specifies the location point for the graphical stretch handle
on the layout rectangle.  The value must be one of
\begin{quote}
``{\vt Location.CENTER\_LEFT}'',\\
``{\vt Location.LOWER\_CENTER}'',\\
``{\vt Location.CENTER\_RIGHT}'',\\
``{\vt Location.UPPER\_CENTER}'',\\
\end{quote}
which specify the left, bottom, right, and top sides.  All Ciranova
codes are handled, those listed above display a line stretch handle,
others will show a glyph.

\item{\vt userScale}\\
This is a real number scale factor used to multiply the change in
parameter value.

\item{\vt userSnap}\\
The real number resolution value which should be used for snapping the
parameter value, i.e., the reported parameter value will be an integer
multiple of the {\vt userSnap}.

\item{\vt key}\\
The name used as a key to specify values for multi-valued parameters,
and should be ``{\vt None}'' for ordinary parameters.  Multi-valued
parameters are not supported in {\Xic}.
\end{description}
\end{description}

In {\Xic}, stretch handles are available only in physical mode.  They
are visible in selected, expanded instances only.  A stretch handle is
represented as a double-line highlighting of one of the four edges of
the rectangle to which the {\et rip} property is applied.

The user can drag the highlighted edge in a direction normal to the
edge over a range set in the property.  The edge is ghost-drawn and
attached to the mouse pointer during the move.  Unlike some other move
operations in {\Xic}, only dragging is allowed, clicking on a grip
will do nothing special.  If the associated parameter has a constraint
string defined, the highlighting will be visible only for allowed
values of the parameter.



% -----------------------------------------------------------------------------
% pc_abut 102614
\section{PCell Abutment}
\label{pcabut}
\index{abutment}
\index{auto-abutment}
Auto-abutment is most commonly used in MOS transistor pcells.  If one
overlays two compatible transistor instances, the two instances
reconfigure themselves into a dual-gate configuration, eliminating
redundant geometry.

At this time, the only available example pcell that implements
auto-abutment is the Nmos2 pcell in the IPL\_cni130 library supplied
with the Synopsys (Ciranova) PyCell Studio download.  This is an
OpenAccess Python portable pcell which is part if the IPL (IPLnow.com)
library of open-source portable pcells.

%\ifoa
The following procedure illustrates auto-abutment.

\begin{enumerate}
\item{Download and install the Synopsys PyCell Studio package.  This
is free from Synopsys, but requires registration and a password
mailback.  Versions are available for Linux and Windows, though the
Windows version is not currently supported in {\Xic}.}

\item{Start {\Xic} in an environment that will load the OpenAccess
libraries and Python from the PyStudio.  Use ``{\vt -Tcni}'' to
reference the appropriate technology file.  Edit an empty cell.}

\item{Select the {\cb OpenAccess Libs} button in the {\cb File Menu},
which will bring up the libraries list.}

\item{Select the {\vt IPL\_cni130} library by clicking on the name. 
Then press the {\cb Contents} button.  A new listing window will
appear.}

\item{Scroll down in the new window and click on the {\vt Nmos2}
entry.}

\item{Then click the {\cb Place} button in the bottom-right corner of
the same window.  The {\cb Cell Placement Control} panel will appear. 
Press the {\cb Place} button in this panel.}

\item{The {\cb Parameters} panel will appear, and the cell placement
icon will be attached to the mouse pointer.  Click twice in a drawing
window to place two instances of the cell, far enough apart that they
don't overlap.  Press {\cb Esc} to exit placement mode.}

\item{Use the {\cb Expand} feature from the {\cb View Menu} to set the
display depth so that the instance content will be shown.}

\item{Now for the fun part.  Pop down any pop-up windows or otherwise
move them out of the way.  Select one of the cell instances, and move
it over the other, so that the right contact area of one touches the
left contact area of the other.  Both instances will reconfigure
themselves, and the overlapped contact will be gone!  The structure
represents a dual-gate transistor.}

\item{Move one of the instances well away from the other.  Note that
they revert to their original form.}

\item{Click the {\cb PCell Control} button in the {\cb Edit Menu}.  In
the panel that appears, select {\cb Mode 2 (with contact)} for {\cb
Auto-abutment mode}.}

\item{As before, move one of the instances so that the contacts
overlap.  In this case, note that one of the instances retains the
contact.  This mode inplements trasistors with a shared contact.}
\end{enumerate}

%\else
%
%Unfortunately, this requires OpenAccess to obtain, so is not currently
%available.  Support for auto-abutment, as decribed in Ciranova
%documentation, is implemented within {\Xic}.  An example native
%abutting pcell will be provided at some point.
%\fi

The abutment protocol adheres as closely as possible to the
description from the {\vt eda\_tool\_integration.pdf} document
supplied with the PyCell Studio.  There is one very significant
difference, in that Synopsys incorporates the logic into a separate
non-visual pcell, which is created transiently to handle abutment
events.  In {\Xic}, the logic is built into the program.  Thus,
auto-abutment can be used in native language and Tcl pcells in {\Xic},
as well as Python pcells.  In {\Xic}, the internal logic handles
abutment events, the separate pcell is not used.

Auto-abutment is enabled in a cell through application of a number of
object properties that define aspects of the abutment.  These are
applied to objects created in the sub-master (or inherited from the
super-master).  The {\Xic} properties as described below correspond to
the properties described for abutment in PyCells, with generally
identical syntax.

\begin{description}
\index{properties!ab\_class}
\index{ab\_class property}
\item{\et ab\_class}\\
This is equivalent to the Ciranova {\et pycAbutClass} property.  It is
applied to pin shapes to specify that two pin shapes from different
cells can be abutted.  Only pins with the same {\et ab\_class}
property string can trigger auto-abutment.

\index{properties!ab\_rules}
\index{ab\_rules property}
\item{\et ab\_rules}\\
This is equivalent to the Ciranova {\et pycAbutRules} property.  The
property is applied to each pin shape that can be abutted, and the
string specifies how the pcell parameters are modified for different
abutment modes.

\index{properties!ab\_directs}
\index{ab\_directs property}
\item{\et ab\_directs}\\
This is equivalent to the Ciranova {\et pycAbutDirects} property.  The
property is applied to each pin shape that can be abutted, and the
string contains a comma-separated list of one or more of the string
tokens {\vt left}, {\vt bottom}, {\vt right}, and {\vt top}.  These
specify the valid abutment directions.

\index{properties!ab\_shapename}
\index{ab\_shapename property}
\item{\et ab\_shapename}\\
This is equivalent to the Ciranova {\et pycAbutShapeName} property. 
This property is assigned by the pcell developer to each pin shape
which can be abutted.  It assigns a unique name to the shape.

\index{properties!ab\_pinsize}
\index{ab\_pinsize property}
\item{\et ab\_pinsize}\\
This is equivalent to the Ciranova {\et pycAbutPinSize} The property
is applied to each pin shape which can be abutted, and supplies an
orientation-independent width parameter.

\index{properties!ab\_inst}
\index{ab\_inst property}
\item{\et ab\_inst}\\
This property is applied to instances of abutable cells, and contains
an instance name.  {\Xic} normally does not generate or use instance
names.

\index{properties!ab\_prior}
\index{ab\_prior property}
\item{\et ab\_prior}\\
This property of a pcell instance indicates that the instance is
abutted, and this property contains pre-abutment parameter values for
use in reverting abutment.

\index{properties!ab\_copy}
\index{ab\_copy property}
\item{\et ab\_copy}\\
This property is applied to instances with {\et ab\_prior} properties
that have just been copied.  This will allow parameter reversion of
the copy without touching the partner of the original.
\end{description}


%\ifoa
% -----------------------------------------------------------------------------
% pycell 022513
\section{Synopsys (Ciranova) PyCell Studio}
\label{ciranova}
\index{Ciranova}
\index{Synopsys}
\index{PyCell}
 
Most parameterized cells (pcells) have been written in the Cadence
Virtuoso environment, using the proprietary Skill scripting language
found only in that environment.  These pcells can only be used in a
Virtuoso environment.

Ciranova, Inc., now owned by Synopsys, developed and championed the
idea of portable pcells, pcells that would have published interfaces
and use a common programming language, that could work in any design
environment.  The company provides a free downloadable ``PyCell
Studio'' design kit.  The concept is made possible by the use of
OpenAccess, which has a well-defined framework for pcell support, is
well documented, and source code is published.  Cadence Virtuoso and
most modern tools use OpenAccess.

Though OpenAccess provides support for pcell interfacing and
management, actual execution of the pcell script is exported to
external code supplied as a plug-in.  The plug-in provides an
interface to the language interpreter or compiler and other things
required to execute the script.  This plug-in is supplied by the
system vendor or user.  For example, in a Virtuoso installation, a
Skill plug-in is provided.  OpenAccess comes with example plug-ins for
Tcl and C++.

Ciranova developed a Python plug-in for OpenAccess, with a set of
interface functions for creating geometry and related purposes within
OpenAccess.  Python is a very popular, modern, open source scripting
language.  It is present on any standard Linux system, and is
available for most other operating systems.  Ciranova calls portable
Python-based pcells that use the Ciranova plug-in ``PyCells''.

The PyCell Studio design kit contains tools for viewing, testing, and
creating PyCells.  An example library of PyCells is provided, complete
with technology and display resource files.  It also provides
OpenAccess and Python, so the package is quite complete.  There is
comprehensive documentation and tutorials.

Though Ciranova has been bought by Synopsys, the PyCell Studio remains
available and apparently is still under development.  An industry
group, IPLnow.com, which includes TSMC and other foundries and some
tool vendors, is pushing the cause of ``interoperable'' PDK libraries
based on portable pcells.

Whiteley Research fully supports this effort, and {\Xic} will be
interoperable with the PyCell Studio design kit and PyCells as much as
possible.

\subsection{Connecting to PyCell Studio}

This section describes how {\Xic} can directly interface to the PyCell
Studio example library and technology.  PyCells from the library, or
authored by the user, can be instantiated in {\Xic} cells.

It will be assumed in this discussion that the PyCell Studio has been
downloaded from Synopsys, and installed on your system, which also has
{\Xic} installed.  The PyCell Studio works with Red Hat Enterprise
Linux releases 5 and 6 (and equivalent).  You must choose the same
word size (32 or 64 bits) as your {\Xic} installation.  The
installation location for PyCell Studio is selected by the user, and
we will refer to this location as ``{\vt \$CNI\_ROOT}''.  For example,
{\vt \$CNI\_ROOT} might be {\vt /usr/local/ciranova}.

Although your system will almost certainly have Python installed, it
appears necessary to use the Python provided with the Studio.  In Red
Hat EL6, the Ciranova and stock Python version numbers are the same,
but the libraries are apparently built with different options, and
attempts at using the stock Python have failed (perhaps Synopsys will
fix this?).  You can, however, use your own OpenAccess installation if
you have one and it is reasonably recent.  You can probably also use
OpenAccess from Cadence.

The first step is to make sure that the PyCell Studio installation is
correct by following the steps in the {\vt
\$CNI\_ROOT/quickstart/README.txt} file.

Part of this procedure (step 3) is to source one of the startup files
provided.  This step sets the value of several environment variables,
and forces the system to find the Ciranova Python instead of a local
Python.  It also installs the OpenAccess plug-in for Python.  The user
can customize this script if desired.  It is necessary to source this
file, or otherwise setup the environment as per the file, before
starting {\Xic}.  After finishing, you will want to revert the
environment to the previous state.  Unfortunately, this is difficult. 
You may kill the window and start a new one.

A better way to run {\Xic} in the Ciranova environment would be to
write a script such as the following.  Call it ``{\vt xic.cni}''.

\begin{verbatim}
#! /bin/sh

CNI_ROOT=/usr/local/ciranova
source \$CNI_ROOT/quickstart/bashrc; xic -Tcni \$*
\end{verbatim}

The {\vt CNI\_ROOT} line should be changed to the actual Ciranova
installation location.  After creating the file, make it executable
with
\begin{quote}
\vt chmod 755 xic.cni
\end{quote}

Then, to run {\Xic} in the Ciranova environment, just run this script
instead.  Since it runs in a sub-shell, the environment of the main
shell is not corrupted.  Any command line arguments are passed
through.

Note that above {\Xic} is started with a ``{\vt -Tcni}'' option, which
specifies to use the {\vt xic\_tech.cni} example technology file
provided with {\Xic}.  This uses the {\vt ReadDRF} and {\vt
ReadCniTech} directives to read display resource and technology files
from the Ciranova installation.  However, Ciranova provides a number
of technology files, any you may want to try them.  You will probably
want to copy the {\vt xic\_tech.cni} file to your local directory, so
that it can be edited easily.

Finally, you will need to set up your OpenAccess {\vt lib.defs} to
include the Ciranova libraries.  The {\vt lib.defs} file is a listing
of the OpenAccess libraries available, very similar to the {\vt
cds.lib} file in Cadence.  If no {\vt lib.defs} file exists in the
current directory, using a text editor create the file with a single
line
\begin{quote}
{\vt INCLUDE} {\it path/to/ciranova\/}{\vt /quickstart/lib.defs}
\end{quote}
The {\it path/to/ciranova} is the installation location, what we have
called {\vt \$CNI\_ROOT}.  If there already is a {\vt lib.defs} file,
the line above should be added.

Once setup is complete, we can test it.
\begin{enumerate}
\item{{\vt prompt$>$  ./xic.cni}\\
{\Xic} should start, and the ``Using OpenAccess'' and ``Using Python''
messages should appear in the console.  The layer table will show
perhaps unfamiliar layers, these have been obtained from the Ciranova
technology file.  There shouldn't be any error or warning message
pop-ups.}

\item{Switch the editing context to a new, empty cell, if the current
cell is not empty or is otherwise of value.}

\item{Click the {\cb OpenAccess Libs} button in the {\cb File Menu},
which will exist if OpenAccess is connected (the ``Using OpenAccess''
message appeared).  This will bring up the {\cb OpenAccess Libraries}
panel.  The following libraries will be listed.
\begin{quote}\vt
IPL\_cni130\\
cnVPcellLib
\end{quote} }

\item{Click on the {\vt IPL\_cni130} line to select it, and press the
{\cb Contents} button.  The {\cb Listing} panel should appear, loaded
up with names.}

\item{In the {\cb Contents}, find the {\et Nmos2} entry, and click on
it to select it.}

\item{Press the {\cb Place} button in the {\cb Contents} listing.  The
{\cb Cell Placement Control} panel will appear.  Press the {\cb Place}
button in this panel, and the {\cb Parameters} pop-up will appear. 
There will be a double-line box ``attached'' to the mouse pointer.}

\item{Have a quick look at the {\cb Parameters} panel.  These are the
pcell parameters that can be set.  Feel free to enter some new values. 
The documentation for the {\vt Nmos2} pcell will explain what the
parameters are, though a few, such as {\vt fingers}, {\vt l}, and {\vt
w}, are obvious.}

\item{Click anywhere in the drawing window to place an instance.  You
should expand the view to show the instance content, press {\kb
Ctrl-x} for this.  You can place more instances, perhaps with
different parameters set.  Press the {\kb Esc} key when done.}

\item{Click on one of the instances to select it.  Note that some of
the sides of certain features are highlighted.  These are stretch
handles that can be dragged, to change the size of the feature.  Try
dragging a handle and note the effect.}

\item{Place a second instance of {\vt Nmos2} so that it doesn't
overlap ther first.}

\item{Move the second instance, place it so that one of the S/D
contacts overlaps a contact of the first instance.  Note that the
overlapping contact has disappeared in both instances.  This is
auto-abutment.  the two instances can be repositioned so as to exactly
share the common edge, which implements a dual-gate transistor.}

\item{Press the {\cb PCell Control} button in the {\cb Edit Menu},
which will display the {\cb PCell Control} pop-up.  In the pop-up,
change the {\cb Auto-abutment mode} to {\cb Mode 2 (with contact)}.}

\item{Move one of the cell instances well away from the other, note
that both instances revert to the original form.  Now drag and drop
one of the instances over the other so that they share a contact, as
before.  This time, however, note that a common contact is retained.}
\end{enumerate}

This should be enough to get started, have fun!
%\fi


% -----------------------------------------------------------------------------
% cdscompat 032117
\section{Cadence$^{TM}$ Compatibility}
\label{cdscompat}
\index{Cadence compatibility}

%\ifoa
Limited compatibility with Cadence Virtuoso$^{TM}$ is available on two
levels.  First, technology, display resource (DRF), and layer mapping
files can be read directly by {\Xic}.  These files are generally
provided in vendor-supplied process design kits intended for use with
Cadence Virtuoso.  Second, the OpenAccess plug-in allows {\Xic} to
access the Cadence libraries directly.  Designs can be loaded into
{\Xic}, however presently they cannot be returned to Virtuoso without
losing data required by Virtuoso.
%\else
%Limited compatibility with Cadence Virtuoso$^{TM}$ is available.  The
%ASCII technology, display resource (DRF), and layer mapping files can
%be read directly by {\Xic}.  These files are generally provided in
%vendor-supplied process design kits intended for use with Cadence
%Virtuoso.
%\fi

For export to a Cadence environment, the {\cb !dumpcds} command will
create compatible technology and DRF files based on the {\Xic}
technology file in use.

Import of a Cadence technology environment is handled by three
keywords which are given in the {\Xic} technology file.  In fact, a
minimal technology file can consist of little more than these
keywords.  The keywords should appear in the order given, but
otherwise can appear anywhere in the {\Xic} technology file.

\begin{description}
\item{\vt ReadDRF} {\it drf\_file}\\
This reads the display resource file (DRF), which creates tables
of layer colors, fill patterns, and similar for use in displays.

\item{\vt ReadCdsTech} {\it techfile}\\
This will read a Virtuoso ASCII technology file.  The technology file
contains the layer definitions, and usually quite a lot of technology
information.  From this, many of the {\it Xic} design rules and
extraction keywords can be obtained.

%\ifoa
\item{\vt ReadOaTech} {\it library}\\
This will obtain Virtuoso technology information directly from
OpenAccess.  The {\it library} is an OpenAccess library, listed in
the {\vt lib.defs} or {\vt cds.lib} file.  This obtains technology
information by use of the OpenAccess plug-in.  There should be no
reason to use both this and {\vt ReadCdsTech}, as they should
retrieve the same information.
%\fi

\item{\vt ReadCdsLmap} {\it filename}\\
The {\it filename} is the path to a Virtuoso layer mapping file.  This
provides GDSII layer/datatype numbers for the layers.  This must
appear in the {\Xic} technology file after {\vt ReadCdsTech}.
\end{description}

An {\Xic} technology file can consist of these statements only.  This
will set the layers and their colors, fill patterns, and some or all
of the electrical, extraction, and design rule information.

When a technology file is written with the {\cb Save Tech} command, it
will have the usual format and the lines described above are {\bf not}
included in the new file.

The ability to read the Lisp/Skill file format used by Virtuoso is
provided by an internal Lisp parser.  The parser is available to run
general scripts through the {\cb !lisp} command, though this has
limited utility at present.

In the technology file, is is sometimes useful to enable debugging
output from the Lisp parser.  The following keyword enables this.

\begin{description}
\item{\vt LispLogging} [{\vt y/n}]\\
If this boolean keyword is set in the technology file, a log file will
be generated when the Lisp parser is used.  This can be used to track
down issues when parsing Virtuoso-style input files.  Asserting this
keyword is equivalent to setting the Lisp logging in the {\cb Logging
Options} panel from the {\cb Help Menu}, which otherwise can't be done
before the technology file is read on program startup.
\end{description}


% -----------------------------------------------------------------------------
% lisp 032117
\subsection{The Lisp Parser}
\label{lisp}
\index{Lisp parser}
\index{Lisp language}
The language supported here is similar to Lisp, and to the Cadence
Skill language.  The intention is not to replicate all features of
these languages, but to provide a minimal subset of features for
compatibility.  The language will be referred to as ``Lisp'', but it
should not be confused with the full-blown programming language.

The language differs from classic Lisp in that algebraic expressions
within lists are evaluated, as in Skill.  These reduce to a number
token.  One subtlety is detection of unary minus, for example {\vt (2
-1)} could be interpreted as a list of two numbers, or one number
(the difference).  The parser will assume a unary minus if the
preceding character is space or `{\vt (}', and the following
character is an integer or period followed by an integer.

One of the advantages of Lisp is the ease with which the syntax
can be parsed.  The basic data object is a ``node'', which has the form
\begin{quote}
[{\it name\/}]( {\it data} ... )
\end{quote}
If a node has a {\it name}, there is no space between the name and the
opening parenthesis.  A named node is roughly equivalent to a function
call.  The {\it data} can be nodes, strings, or numerical expressions. 
The items are separated by white space.  The {\it data} can use
arbitrarily many lines in the input file.

Lisp variables are defined when assigned to, and have global scope
unless declared in a {\vt let} node, in which case their scope is
within the {\vt let} node, i.e., local.

A Lisp file consists of one or more named nodes.  When the file is
accessed with the {\cb !lisp} command, each of the nodes is evaluated. 
The nodes must have names that are known to {\Xic}.  These are:

\begin{description}
\item{\vt main}\\
The content of this node is evaluated.  This is a special name for the
"main" function of a script.
\item{Built-in function name}\\
These are the basic Lisp functions and operator-equivalents.
\item{{\Xic} function name}\\
All of the {\Xic} script functions will be recognized, however in Lisp
the first character of these functions is always lower case.  i.e.,
the {\vt Edit} script function would be accessed as {\vt edit}( ) in
Lisp.  Also, only {\Xic} functions that take string or numeric
arguments will work at present.
\item{User-defined procedures}\\
These are Lisp functions defined by the user with the Lisp {\vt
procedure}( ) function.
\item{Cadence compatibility name}\\
There is a growing number of node names that are used to interpret
Cadence startup and control files (see \ref{cdscompat}).
\end{description}

A node name that can't be resolved will generate an error.

The parser uses the same numerical parser as the {\WRspice} program,
and hence recognizes numbers in the same (SPICE) format.  All of the
math functions based on the standard C library, as used in the native
scripting language, are available.

The following built-in node names are recognized.

\begin{tabular}{|l|l|} \hline
\multicolumn{2}{|c|}{\kb Operator Equivalents}\\ \hline
\vt expt &       \vt expt(x y)       $\Longleftrightarrow  x \symbol{94} y$\\ \hline
\vt times &      \vt times(x y)      $\Longleftrightarrow  x * y$\\ \hline
\vt quotient &   \vt quotient(x y)   $\Longleftrightarrow  x / y$\\ \hline
\vt plus &       \vt plus(x y)       $\Longleftrightarrow  x + y$\\ \hline
\vt difference & \vt difference(x y) $\Longleftrightarrow  x - y$\\ \hline
\vt lessp &      \vt lessp(x y)      $\Longleftrightarrow  x < y$\\ \hline
\vt leqp &       \vt leqp(x y)       $\Longleftrightarrow  x <= y$\\ \hline
\vt greaterp &   \vt greaterp(x y)   $\Longleftrightarrow  x > y$\\ \hline
\vt geqp &       \vt geqp(x y)       $\Longleftrightarrow  x >= y$\\ \hline
\vt equal &      \vt equal(x y)      $\Longleftrightarrow  x == y$\\ \hline
\vt nequal &     \vt nequal(x y)     $\Longleftrightarrow  x$ $!=$ $y$\\ \hline
\vt and &        \vt and(x y)        $\Longleftrightarrow  x$ $\&\&$ $y$\\ \hline
\vt or &         \vt or(x y)         $\Longleftrightarrow  x$ $||$ $y$\\ \hline
\vt colon &      \vt colon(x y)      $\Longleftrightarrow  '(x y)
   \Longleftrightarrow x : y$\\ \hline
\vt setq &       \vt setq(x y)       $\longleftrightarrow  x = y$\\ \hline
\multicolumn{2}{|c|}{\kb Lists}\\ \hline
\vt ' &          returns list of arguments\\ \hline
\vt list &       returns substituted list of arguments\\ \hline
\vt cons &       add element to front of list\\ \hline
\vt append &     append lists\\ \hline
\vt car &        return leading element of list\\ \hline
\vt cdr &        return list starting at second element\\ \hline
\vt nth &        return N'th element of list\\ \hline
\vt member &     return true if element in list\\ \hline
\vt length &     return length of list\\ \hline
\vt xCoord &     return first element of list\\ \hline
\vt yCoord &     return second element of list\\ \hline
\multicolumn{2}{|c|}{\kb Miscellaneous}\\ \hline
\vt main &       main function\\ \hline
\vt procedure &  define a procedure\\ \hline
\vt argc &       command line argument count\\ \hline
\vt argv &       command line argument list\\ \hline
\vt let &        variable scope container\\ \hline
\end{tabular}


% -----------------------------------------------------------------------------
% ReadDRF 021913
\subsection{The {\vt ReadDRF} keyword}
\index{ReadDRF keyword}

This technology file keyword is used to import a Cadence Virtuoso
display resource (DRF) file into {\Xic}.  The syntax is
\begin{quote}
{\vt ReadDRF} {\it drf\_file}
\end{quote}

The display resource file is generally provided by a process design
kit intended to be used with Virtuoso.  The file contains definitions
of the layer colors and fill patterns, and other presentation
attributes.  Although the names may vary, the display resource file in
one installation is named ``{\vt display.drf}''

The display resource file (DRF) ia a collection of ``nodes'', as
understood by the Lisp parser.  A named node has the form
\begin{quote}
{\it name}{\vt (} {\it data} {\vt ... )}
\end{quote}
There can be no space between the node name and the opening
parenthesis.  The {\it data} are other Lisp nodes, strings, or
numerical data or expressions.  This can occupy arbitrarily many lines
in the file.  The DRF file consists of successive Lisp nodes, with
names and expected content defined by Cadence.

The following top-level display resource Lisp nodes are understood by
{\Xic}.  Presently, the only effect from these nodes is the creation
of internal lists of data items, which are referenced by the nodes
given in the Cadence ASCII technology file.  Thus, reading in the
display resource file has no effect on {\Xic} operation other than
providing display attributes for layers defined in the Cadence ASCII
technology file.

\begin{description}
\item{\vt drDefineDisplay}\\
This node is ignored.

\item{\vt drDefineColor}\\
For all entries with a display name of ``{\vt display}'', the color is
added to an internal color list.  This internal list will be
referenced in the technology file {\vt techDisplays} node.

\item{\vt drDefineStipple}\\
For all entries with a display name of ``{\vt display}'', the stipple
pattern is added to an internal stipple list.  This internal list will
be referenced in the technology file {\vt techDisplays} node. 

\item{\vt drDefineLineStyle}\\
This node is ignored.

\item{\vt drDefinePacket}\\
For all entries with a display name of ``{\vt display}'', the packet
is added to an internal packet list.  This internal list will be
referenced in the technology file {\vt techDisplays} node.
\end{description}

% -----------------------------------------------------------------------------
% ReadCdsTech 062016
\subsection{The {\vt ReadCdsTech} keyword}
\index{ReadCdsTech keyword}

This technology file keyword is used to import a Cadence Virtuoso
ASCII technology file into {\Xic}.  The syntax is
\begin{quote}
{\vt ReadCdsTech} {\it techfile}
\end{quote}

The ASCII technology file is generally provided in process design kits
intended for use with Virtuoso.  The file name varies, but ``{\vt
techfile}'' and ``{\vt techfile.txt}'' have been used.  The file at
minimum provides the list of layers used in the process.  Generally,
there is a wealth of technology information available, and the file
can be quite large and complex.

If a display resource file is also being read, it should be read
first.  Other than this, {\vt ReadCdsTech} can appear anywhere in the
technology file, and will cause {\Xic} to read information from the
Cadence ASCII technology file given in {\it techfile}.  This should be
a full path to the file, unless the file is in the library search
path.

The technology file is collections of ``nodes'', as understood by the
Lisp parser.  A named node has the form
\begin{quote}
{\it name\/}{\vt (} {\it data} {\vt ... )}
\end{quote}
There can be no space between the node name and the opening
parenthesis.  The {\it data} are other Lisp nodes, strings, or
numerical data or expressions.  This can occupy arbitrarily many lines
in the file.  The file consists of successive Lisp nodes, with names
and content that are defined by Cadence or OpenAccess.  The nodes that
are understood by {\Xic} are described below.

Both Virtuoso 5.x and 6.x technology files can be read.  Far more
information can be obtained from 6.x (OpenAccess) technology files,
however.  This includes:

\begin{itemize}
\item{Extraction technology keywords such as {\vt Conductor}, {\vt
Via}, etc.  (as are available from 5.x files) but additionally
electrical/physical data such as {\vt Thickness}, resistivity, and
capacitance parameters are available.}

\item{Design rules are generated from the ``constraint groups''.}
\end{itemize}

This will provide a much more complete starting point from the
technology file provided with a foundry kit.  However, this still may
be incomplete.  For example, a typical technology file may provide
thickness values for conductors only, not insulators.

Depending on the PDK, the imported design rules and derived layer
definitions may require review and augmentation.  The ``real'' design
rules are likely provided in separate configuration files for Mentor
Calibre, Cadence Assura, and/or others.  In experience with one PDK,
it was found that the rule set obtained through the OpenAccess
technology database left a lot to be desired.

\begin{enumerate}
\item{The very basic rules, such as {\vt MinWidth} and
{\vt MinSpace} came through fine, including the spacing tables.
Other simple rules also come through properly.}

\item{Derived layers come across fine, however within the syntax
limitation, expresions are limited to a single operator, i.e., a form
like ``{\it layer operator layer\/}''.  Thus, a complex definition
requires multiple derived layers for intermediate layers, which is
acceptable.  It was concerning, though, that the derived layers were
not used anywhere within the technology file, such as in the
constraints.  There seemed also to be errors, for example one obvious
place where ``{\vt `and}'' was used where ``{\vt `or}'' was clearly
required.}

\item{The constraints helpfully included a design rule violation
number, but were shown to be wrong when the rule was looked up.  For
example, One rule specified ``(PP OR NP) Enclosure of PO ...'', yet
there were separate constraints ``PP Enclosure PO...'' and ``NP
Enclosure PO...'' specified, which is wrong.}

\item{An attempt to DRC a known-clean layout with imported rules
yielded a lot of bogus errors.  Additional work would be necessary
to obtain a ``good'' set of design rules.}

\item{As more tools use OpenAccess, perhaps there will be
improvements in the rulesets provided through the OpenAccess
technology database.  At present, it appears that this is not
primary to the serious DRC tools, but may be used by Virtuoso,
possibly for editing feedback.}
\end{enumerate}

The tree below shows the hierarchy of the nodes that are recognized in
the technology file.  Most of these are ignored.  Below we describe
the nodes that are actually used, and what information they provide.

Below, nodes that were added for Virtuoso 6.1.4 are marked marked with
an asterisk.  The\\
{\vt constraintGroups} listing is greatly simplified, there is
actually far more structure than indicated.

\begin{quote}
\begin{verbatim}
    include
    comment
    controls
        techParams
        techPermissions
        viewTypeUnits *
        mfgGridResolution *
    layerDefinitions
        techLayers
        techPurposes
        techLayerPurposePriorities
            techDisplays
            techLayerproperties
            techDerivedLayers *
    layerRules
        functions *
        routingDirections *
        stampLabelLayers *
        currentDensityTables *
        viaLayers
        equivalentLayers
        streamLayers
    viaDefs *
        standardViaDefs *
        customViaDefs *
    constraintGroups *
        foundry *
            spacings *
                maxWidth
                minWidth
                minDiagonalWidth
                minSpacing
                minSameNetSpacing
                minDiagonalSpacing
                minArea
                minHoleArea
            viaStackLimits *
            spacingTables *
            orderedSpacings *
                minOverlap
                minEnclosure
                minExtension
                minOppExtension
            antennaModels *
            electrical *
        LEFDefaultRouteSpec *
            interconnect *
                maxRoutingDistance *
            routingGrids *
                verticalPitch *
                horizontalPitch *
                verticalOffset *
                horizontalOffset *
    devices
        tcCreateCDSDeviceClass
        multipartPathTemplates *
        extractMOS *
        extractRES *
        symContactDevice
        ruleContactDevice
        symEnhancementDevice
        symDepletionDevice
        symPinDevice
        symRectPinDevice
        tcCreateDeviceClass
        tcDeclareDevice
    viaSpecs *
    physicalRules
        orderedSpacingRules
        spacingRules
        mfgGridResolution
    electricalRules
        characterizationRules
        orderedCharacterizationRules
    leRules
        leLswLayers
    lxRules
        lxExtractLayers
        lxNoOverlapLayers
        lxMPPTemplates
    compactorRules
        compactorLayers
        symWires
        symRules
    lasRules
        lasLayers
        lasDevices
        lasWires
        lasProperties
    prRules
        prRoutingLayers
        prViaTypes
        prStackVias
        prMastersliceLayers
        prViaRules
        prGenViaRules
        prTurnViaRules
        prNonDefaultRules
        prRoutingPitch
        prRoutingOffset
        prOverlapLayer
\end{verbatim}
\end{quote}

We mention below only the nodes from which information is extracted. 
Note that this is a mixture of 5.x and 6.x nodes, providing unified
support for all current Virtuoso releases.  In most cases, a node with
an unrecognized name will produce a warning message.  These can be
ignored, the purpose is only to identify ``new'' information in the
technology file that might be useful to parse.

\begin{description}
\item{\vt include}\\
This node contains a string, which is a path to another Lisp file. 
That file will be opened and read.

\item{\vt controls/viewTypeUnits}\\
For {\vt maskLayout}, if {\vt microns}, the {\Xic} database
resolutions 1000, 2000, 5000, 10000, and 20000 are accepted.

\item{\vt controls/mfgGridResolution}\\
This will set the {\Xic} {\et MfgGrid} parameter.

\item{\vt layerDefinitions/techLayers}\\
This associates OpenAccess layer numbers with layer names and
abbreviations.  These are recorded in the {\Xic} layer database.

\item{\vt layerDefinitions/techPurposes}\\
This associates OpenAccess purpose numbers with purpose names and
abbreviations.  These are recorded in the {\Xic} layer database.

\item{\vt layerDefinitions/techLayerPurposePriorities}\\
This contains a list of layer-purpose pairs, using layer and purpose
names previously defined.  Each layer-purpose pair is used to create
an {\Xic} layer.  These are created in the order listed.
 
In Virtuoso, there is no distinction between physical and electrical
layers as there is in {\Xic}.  All Virtuoso layers are taken as
physical layers, except for the following internal Virtuoso layer
numbers which with any purpose number will generate an {\Xic} layer
listed in both the electrical and physical layer tables in {\Xic}.
 
\begin{quote}
\begin{tabular}{ll}
\bf Layer Number & \bf Virtuoso Layer Name\\
228 & \vt wire\\
229 & \vt pin\\
230 & \vt text\\
231 & \vt device\\
236 & \vt instance\\
237 & \vt annotate\\
\end{tabular}
\end{quote}

\item{\vt layerDefinitions/techDisplays}\\
This will assign the colors and fill patterns to layers that exist in
the {\Xic} layer table.  This references the internal packet, color,
and stipple lists created from the display resource nodes.  In
addition, the initial visibility and selectability states are set
here, as well as the {\et Invalid} flag.

\item{\vt layerDefinitions/techLayerproperties}\\
This node provides some directly applicable parameters, which are read
and added to the appropriate layer.  These include {\vt
sheetResistance}, {\vt areaCapacitance}, {\vt edgeCapacitance}, and
{\vt thickness}.  The thickness value is specified in angstroms, which
is converted to microns.  The capacitance value units are picofarads
and microns, thus no conversion is required.

\item{\vt layerDefinitions/techDerivedLayers}\\
The derived layers will be imported directly, with the expression
converted to an {\Xic} layer expression string.  The expression given
in this node type consists of a single operator and two layer names. 
The operator keywords which map to geometrical combinations ({\vt
'and}, {\vt 'or}, {\vt 'not}, and {\vt 'xor}) are accepted.  Others
are ignored.

\item{\vt layerRules/routingDirections}\\
Layers found in this table are given the {\vt Routing} attribute.

\item{\vt layerRules/viaLayers}\\
The conducting layers are assigned the {\vt Conductor} attribute.  The
via layer is assigned the {\vt Via} attribute.  This is in 5.x files
only.

\item{\vt layerRules/streamLayers}\\
A GDSII import/export mapping is applied for each layer given.  This
is in 5.x files only.

\item{\vt viaDefs/standardViaDefs}\\
This identifies layers that are given the {\vt Via} attribute.  The
metal layers that are referenced by the via are given the {\vt
Conductor} attribute.  The standard via definition is imported, and
will be available for via generation from the {\cb Via Creation} panel
from the {\cb Edit Menu}.

\item{\vt constraintGroups/foundry/spacings/maxWidth}\\
This identifies a {\vt MaxWidth} rule.

\item{\vt constraintGroups/foundry/spacings/minWidth}\\
This identifies a {\vt MinWidth} rule.

\item{\vt constraintGroups/foundry/spacings/minDiagonalWidth}\\
This will map to a {\vt Diagonal} clause in a {\vt MinWidth} rule.

\item{\vt constraintGroups/foundry/spacings/minSpacing}\\
This maps to either a {\vt MinSpace} rule (one layer given) or a {\vt
MinSpaceTo} rule if two layers are given.

\item{\vt constraintGroups/foundry/spacings/minSameNetSpacing}\\
This provides the {\vt SameNet} clause to a {\vt MinSpace} or {\vt
MinSpaceTo} rule.

\item{\vt constraintGroups/foundry/spacings/minDiagonalSpacing}\\
This provides the {\vt Diagonal} clause to a {\vt MinSpace} or {\vt
MinSpaceTo} rule.

\item{\vt constraintGroups/foundry/spacings/minArea}\\
This identifies a {\vt MinArea} rule.

\item{\vt constraintGroups/foundry/spacings/minHoleArea}\\
This provides the dimension for area filtering in a {\vt NoHoles}
rule.

\item{\vt constraintGroups/foundry/spacings/minHoleWidth}\\
This provides the dimension for minimum width filtering in a {\vt
NoHoles} rule.

\item{\vt constraintGroups/foundry/spacingTables}\\
This provides tables of length, width, and spacing values, for
size-dependent spacing rules.  These tables are parsed and added to
{\vt MinSpace} and {\vt MinSpaceTo} rules.

\item{\vt constraintGroups/foundry/orderedSpacings/minEnclosure}\\
This maps to a {\vt MinSpaceFrom} rule, with the source and target
layers swapped.  It provides the {\vt Enclosed} clause, which applies
when the target figure is completely surrounded by the source
material.  The alias {\vt minEnclosureDistance} is also recognized.

\item{\vt constraintGroups/foundry/orderedSpacings/minExtension}\\
This is almost identical with {\vt minEnclosure}, but does not require
that the target figure be fully surrounded.  It maps to a {\vt
MinSpaceFrom} rule in the same manner, but sets the rule dimension,
not the {\vt Enclosed} value.  The alias {\vt minOverlapDistance} is
also recognized.

\item{\vt constraintGroups/foundry/orderedSpacings/minOppExtension}\\
This is handled similarly to the two rules above, but sets the {\vt
Opposite} clause of the {\vt MinSpaceFrom} rule.

\item{\vt constraintGroups/LEFDefaultRouteSpec/interconnect/maxRoutingDistance}\\
This provides the {\et maxdist} routing parameter (see \ref{exkwords}).

\item{\parbox{4in}{\vt constraintGroups/LEFDefaultRouteSpec/routingGrids/horizontalPitch\newline
constraintGroups/LEFDefaultRouteSpec/routingGrids/verticalPitch}}\\
These provide the {\et pitch} routing parameter (see \ref{exkwords}).

\item{\parbox{4in}{\vt constraintGroups/LEFDefaultRouteSpec/routingGrids/horizontalOffset\newline
constraintGroups/LEFDefaultRouteSpec/routingGrids/verticalOffset}}\\
These provide the {\vt offset} routing parameter (see \ref{exkwords}).

\item{\vt layerRules/routingDirections}\\
This provides the preferred routing direction.

\item{\vt constraintGroups/foundry/spacings/minWidth}\\
This maps to the {\et width} routing parameter (see \ref{exkwords}).
\end{description}


%\ifoa
% -----------------------------------------------------------------------------
% ReadOaTech 032117
\subsection{The {\vt ReadOaTech} keyword}
\index{ReadOaTech keyword}
This is similar to {\vt ReadCdsTech}, however it retrieves the tech
data from OpenAccess relative to a given library, instead of from the
ASCII technology file.  The syntax is
\begin{quote}
{\vt ReadOaTech} {\it library}
\end{quote}
 
The {\it library} must be listed in the OpenAccess library
definitions file, named {\vt lib.defs} or named {\vt cds.lib} in
Cadence installations.  The OpenAccess plug-in is used to obtain the
information, and of course must be available and set to connect to an
OpenAccess database.
 
The technology information is extracted into a temporary Virtuoso
ASCII technology file, which is then parsed by the equivalent of
specifying {\vt ReadCdsTech} with this file.  The same file can be
obtained from the print option of the {\cb !oatech} command.  This
can be used to view the tech information that is being extracted.
%\fi


% -----------------------------------------------------------------------------
% ReadCdsLmap 021913
\subsection{The {\vt ReadCdsLmap} keyword}
\index{ReadCdsLmap keyword}
This technology file keyword allows import of a Cadence Virtuoso layer
mapping file.  This file provides the layer/datatype numbers for the
layers defined in the display resource file.  It is important that
these numbers be equivalent in {\Xic} for success in transferring
design data via GDSII or OASIS files.  The file is generally provided
within a process design kit.  The name of the file will vary, in one
case it is the name of the technology with a ``{\vt .layermap}''
extension. 

The syntax is 
\begin{quote}
{\vt ReadCdsLmap} {\it filename}
\end{quote}
       
The {\it filename} is a path to the Virtuoso layer mapping file.  This
must appear in the {\Xic} technology file after the {\vt ReadCdsTech}
line, as the layers must exist in the {\it Xic} database before they
can be assigned a GDSII mapping. 

%\ifoa
% -----------------------------------------------------------------------------
% cdsconnect 022416
\subsection{Connecting to Cadence Installations}
\index{Cadence connection}

The OpenAccess plug-in (see \ref{oaplugin}) makes it possible for
{\Xic} to access Cadence cell libraries, by making use of the
OpenAccess libraries provided with the Cadence installation.

When accessing Virtuoso design data, {\Xic} should be provided with a
consistent technology file.  The Cadence compatibility features
include the ability to read Virtuoso display resource, ASCII
technology, and GDSII layer mapping files.  These files are provided
in the process design kit in use.  The user should create a skeletal
{\Xic} technology file which will read these files.  Then, layout
appearance will be consistent between Virtuoso and {\Xic}.

\subsubsection{Compatibility and Setup}

The present release of {\Xic} is known to be compatible with Virtuoso
6.1.6 in terms of OpenAccess versioning.  It is very likely compatible
with earlier 6.1.{\it x} releases, but these have not been tested,
though 6.1.4 has been verified with earlier {\Xic} releases.

The installation location of the Cadence tools may be set in the
environment variable {\et CDSHOME}.  The user should verify that this
variable is set in the environment.  If not, the user must locate the
installation directory for Cadence tools some other way.

Listing the installation directory, e.g.,
\begin{quote}
{\vt ls \$CDSHOME}
\end{quote}
will provide a listing of files and subdirectories, which include the
names ``{\vt tools}'' and ``{\vt tools.lnx86}''.  In addition, there
will be a subdirectory (perhaps more than one) with a name similar or
identical to ``{\vt oa\_v22.43.050}''.  This is OpenAccess.  In this
directory you will find a ``{\vt lib}'' directory containing
subdirectories with library files for 32 and 64-bit systems.  The
files of interest will match the {\Xic} installation bit-width.  The
OpenAccess provided with Virtuoso 6.1.6 is newer than the publicly
available version of OpenAccess that {\Xic} is compiled against, but
that does not appear to matter.  If there are multiple OpenAccess
versions present, probably the newest one (largest release numbers)
should be used, but if problems are encountered other versions can be
tried.

The full path to the directory containing the appropriate
OpenAccess shared library files must be added to the system's
library search string.  On an example Cadence installation, the
path, for 64-bits, is
\begin{quote}
\vt \$CDSHOME/oa\_v22.43.050/lib/linux\_rhel50\_gcc44x\_64/opt
\end{quote}
In addition, callbacks may require that {\Xic} have access to
additional shared libraries supplied by Cadence.  For 64-bits,
this directory is
\begin{quote}
\vt \$CDSHOME/tools.lnx86/lib/64bit
\end{quote}

Traditionally in Unix/Linux, the shared library search path is
modified by setting the\\ {\et LD\_LIBRARY\_PATH} environment variable. 
This variable provides additional locations for the system to search
for needed shared libraries, in addition to system default locations
that are implicit.

This variable can be used to set the search path, but in {\Xic} there
is a better way:  set the\\ {\et XIC\_LIBRARY\_PATH} environment
variable instead.  This is like {\et LD\_LIBRARY\_PATH}.  but applies
only to the {\Xic} program.  Setting {\et LD\_LIBRARY\_PATH} applies
to all programs, whether they need the additional search locations or
not.

The {\et XIC\_LIBRARY\_PATH} variable is most conveniently set in the
user's shell startup file.  The variable string consists of a list of
directories, separated by colon (`{\vt :}') characters.  The
directories in the list are searched left-to-right to resolve shared
library references, when a program is started.  One should probably
also include the value of the {\et LD\_LIBRARY\_PATH} in case that has
been set for some other reason.

For our example, lines like the following should be added to the shell
startup files.  For {\vt bash} and similar:
\begin{quote}\vt
\# Hook Xic to the Cadence OpenAccess library\\
XIC\_LIBRARY\_PATH=\$CDSHOME/oa\_v22.43.050/lib/linux\_rhel50\_gcc44x\_64/opt\\
XIC\_LIBRARY\_PATH=\$XIC\_LIBRARY\_PATH:\$CDSHOME/tools/lib/64bit\\
export XIC\_LIBRARY\_PATH
\end{quote}
and for C-shell:
\begin{quote}\vt
\# Hook Xic to the Cadence OpenAccess library\\
setenv XIC\_LIBRARY\_PATH \$CDSHOME/oa\_v22.43.050/lib/linux\_rhel50\_gcc44x\_64/opt\\
setenv XIC\_LIBRARY\_PATH \$XIC\_LIBRARY\_PATH:\$CDSHOME/tools/lib/64bit
\end{quote}
Similar commands can be given on the command line.

Once the new definitions apply, when {\Xic} starts, the following
message should appear on the console among the initial startup
messages:
\begin{quote}
\vt Using OpenAccess (oa.so).
\end{quote}
If the message is not seen, try setting the {\et XIC\_PLUGIN\_DBG}
environment variable and starting {\Xic} again.  Messages printed in
the console window should indicate where the error occurs.

With OpenAccess successfully connected, the {\cb File Menu} will
contain the {\cb OpenAccess Libs} button.  If {\Xic} was started in a
directory with a {\vt cds.lib} file, the libraries in the file should
be listed in the pop-up.  Probably, it is best when working with
{\Xic} to work from a different directory than when working with
Virtuoso.  If so, you will want to copy in your {\vt cds.lib} file,
which defines the Cadence libraries available.  You can modify this
copy with a text editor if desired.  The libraries will be listed in
the {\cb OpenAccess Libraries} panel if they exist.

\subsubsection{Express PCells}

In Virtuoso, foundry devices are most likely represented as
parameterized cells (pcells).  These are cells with an internal script
which generates a physical layout according to a set of device
parameters.

Parameterized cells in the Cadence environment are most probably based
on the Skill language and are not portable outside of a Cadence
environment.  However, Virtuoso provides a feature called ``Express
PCells'' which caches pcell sub-masters in the user's home directory. 
A pcell sub-master is an ordinary cell, created from a pcell using a
specific parameter set.  The pcell cache provides the benefit that
pcell evaluation is avoided, so that designs may be opened more
quickly.  A second advantage is that the cached sub-masters, unlike
the pcells, can be exported.

Before a design containing Skill-based pcell instances can be fully
loaded into {\Xic}, the Express PCell feature must be enabled, and all
of the pcell submasters must be cached.

One should be aware that if only a schematic is being imported into
{\Xic}, it isn't necessary to worry about pcells, as the pcell
schematic symbol is available.  Only the physical layout changes with
different device parameters.

To enable Express PCells, the environment variable
{\et CDS\_ENABLE\_EXP\_PCELL} should be set to ``{\vt true}''.
Again, this is most conveniently done in the user's shell
startup script.  For {\vt bash}:
\begin{quote}
\vt export CDS\_ENABLE\_EXP\_PCELL=true
\end{quote}
For C-shell:
\begin{quote}
\vt setenv CDS\_ENABLE\_EXP\_PCELL true
\end{quote}

From a Virtuoso Layout Editor window, the {\cb Tools} menu will
contain an {\cb Express PCell Manager} button.  This brings up a
window allowing control of the feature.  With the feature on, loading
a design will populate the cache.  It should then be possible to load
the same design into {\Xic}, with no unresolved pcell references. 
Note that when obtaining the pcell sub-masters through OpenAccess, a
license checkout for the Cadence system occurs.  Cadence will not
export a sub-master from the cache without a license.
%\fi


%\ifoa
% -----------------------------------------------------------------------------
% cdsimport 022816
\subsection{Importing a Design from Virtuoso}
\index{Cadence importation}

Once the OpenAccess database of a Cadence Virtuoso installation is
connected to {\Xic}, designs created in Virtuoso can be imported
into {\Xic}.  Physical (layout) data should transfer without issues. 
Schematic and schematic symbol data will transform as electrical
cells, some of which are devices.  These will probably work
successfully as {\Xic} cells, but it is possible that a bit of
intervention will be needed.  It is disasterous if the cells are
written back to Virtuoso.  By default, Virtuoso libraries are
read-only in {\Xic} to prevent this from happening.

{\Xic} obtains technology information from its own technology file,
and (presently) not directly from OpenAccess.  However, the same
technology information should be available to {\Xic} through direct
reading of the appropriate {\vt display.drf} and ASCII technology
files.  These files should be available in the process design kit in
use.

The user's {\vt cds.lib} file (or a copy) should exist in the current
directory.  This file will be used and updated by {\Xic}.  It is fine
to share a {\vt cds.lib} with an active Virtuoso installation, but it
is probably better to maintain separate files, so that the {\Xic}
libraries, which are presently incompatible with Virtuoso, are
invisible in Virtuoso.

If the OpenAccess database is connected, the {\cb OpenAccess
Libraries} panel, from the {\cb OpenAccess Libs} button in the {\cb
File Menu}, will display the libraries that are defined in the {\vt
cds.lib} file.  The button will appear in the {\cb File Menu} only if
an OpenAccess database is connected.

From the panel, one can select a library by clicking on the listing,
and list the contents with the {\cb Contents} button in the panel. 
Pressing the {\cb Contents} button brings up a listing of the cells
contained in the library.

Presently, {\Xic} does not use ``views'' in the same manner as
Virtuoso.  Each of the listed cell names contain one or more of the
following OpenAccess standard views, which are used to create the
{\Xic} cell.  The {\vt maskLayout} view contributes the physical data. 
The {\vt schematic} view provides the electrical data, and the {\vt
schematicSymbol} view provides the {\Xic} symbolic representation. 
Other views are ignored by {\Xic}.

In the {\cb Listing} panel, one can select cells bu clicking on a
name.  When a cell is selected, the {\cb Open} button becomes active. 
Pressing this button will read that cell, and its hierarchy, into
{\Xic}.  Note that it does not matter whether or not the library is
``open'' in the {\cb OpenAccess Libraries} listing.  The ``open''
status means that cells in the library will resolve instantiations as
archive files are being read, but explicitly read cells, and subcells
referenced in OpenAccess, are always read.

Before data can be successfully read into {\Xic}, Virtuoso
parameterized cells must be cached, using the Cadence Express PCells
feature.  {\Xic} can not create super-masters for Virtuoso
(Skill-based) pcells, but will import cached super-masters.  The
imported cell will be an ordinary cell in {\Xic}, but will retain
properties that identify the cell as originating as a Virtuoso pcell.

Once the hierarchy is read, it should appear visually very similar if
not identical to the corresponding views in Virtuoso, if the
appropriate technology has been accessed properly.  Electrical cells
will always have a symbolic representation, since in Virtuoso
schematic instantiations are always symbolic, unlike in {\Xic}.

If there are errors or warnings emitted during the import, the log
file listing will appear.  The user should inspect this and take
appropriate action if needed.

With the design now local in {\Xic}, it can be saved to disk in any of
the formats supported by {\Xic}.  Initially, it is recommended saving
the imported design as a collection of native cell files, into a clean
directory.  The {\cb Export Control} panel from the {\cb Convert Menu}
can be used for this.  Then, the devices can be ``harvested''.

Initially, a number of the imported cells represent devices.  These
correspond to Virtuoso pcells, and have the same name.  Except for
some terminal devices that are created during translation as needed,
the standard device library is not used.  The imported devices serve
the same purpose as the library devices, and will work in the same
way.  However, they will not appear in the device selection menus, and
they are treated as ordinary cells in the hierarchy.  By
``harvesting'' the devices, we will make ``official'' {\Xic} devices
out of them, allowing use in other designs, and remove them as
ordinary cells in the imported hierarchy.

The following procedure can be used to identify the ``device'' cells. 
Bring up the {\cb Cells Listing} panel from the {\cb Cells Menu}.  In
the lower right-hand corner, select {\cb Elec Cells} in the menu. 
Click the {\cb Filter} button on the side of the listing, which will
bring up the {\cb Cell List Filter} panel.  Make sure that the only
box checked is the one next to {\cb Device} (between {\cb not} and
{\cb Device}).  Then click {\cb Apply}.  The listing will now consist
of the device cells only.  You should save this list, using {\cb Save
Text} or otherwise.

After saving the imported design in a directory as native cell files,
{\Xic} can be exited.  To harvest the devices, we will create a new
directory (if needed), and move the device cells in our list from the
directory containing our design to the new directory.  We will then
add the new directory as a reference in a local {\vt device.lib} file,
if this hasn't been done previously.  Then, next time we use {\Xic},
the devices will be present in the device selection menus, and can be
used in new schematics just as any other device.  Specifically,
suppose that you saved the design as native cell files in a directory
named ``{\vt chip1}'', and you have another directory named ``{\vt
devices}''.  By hand, move each of the files in the list of devices
from {\vt chip1<}to {\vt devices}.  Then, add the {\vt devices}
directory to the {\vt device.lib} file.  The default system-wide {\vt
device.lib} is in the {\vt startup} directory in the installation area
({\vt /usr/local/xictools/xic/startup} by default).  You can modify
this file, or better copy this file to your current directory, and
modify the copy.  With a text editor, add a line to the end of the

{\vt device.lib} file:
\begin{quote}
{\vt Directory}  {\it /full/path/to/your/devices}
\end{quote}

The second token should be the actual full path to the {\vt devices}
directory that you created.  Note that in the future, all that you
need to do to ``install'' a new device is to move the file into your
{\vt devices} directory.

Once finished, one can start {\Xic} again, with the same technology
file, and read in the top-level cell from the saved native cell files
directory.  The devices will be included, now resolved through the
library mechanism.  One may wish to save the design in an archive
format such as OASIS or GDSII, which may be more convenient than the
directory full of cell files.  The archive file will not contain the
devices.  Be aware that to export the design to another {\Xic}
installation, the {\vt devices} directory will have to be exported
too.
%\fi


% -----------------------------------------------------------------------------
% stdvia 022816
\section{Standard Vias}
\label{stdvia}
\index{standard via}

{\Xic} provides a feature for creating and managing via objects used
to connect between conducting layers in physical layouts.  Although
ordinary cells or cut-layer objects can be used for this purpose, use
of standard vias offers some important advantages in many designs.

\begin{itemize}
\item{The vias can contain the structure necessary so that proper use
automatically satisfies design rule constraints.}

\item{The vias are designed to allow a zero search depth for
extraction, speeding this process.}

\item{The creation of the ``sub-master'' cells that implement the vias
is handled transparently by the system, removing the often large
number of ordinary via cells from the cell listings.  The via cells
are no longer written in output, reducing file size and complexity.}

\item{The vias are easily created from the {\cb Via Creation} panel in
the {\cb Edit Menu} and can be placed immediately, which is quick and
efficient.}
\end{itemize}

In order for this feature to be available, one or more standard vias
definitions must appear in the technology file.  These will also be
imported from a Cadence Virtuoso ASCII technology file if the {\vt
ReadCdsTech} keyword is used, and the Cadence database contains {\vt
standardViaDefs} definitions.  The implementation of standard vias in
{\Xic} closely follows the implementation in OpenAccess, and tools
such as Virtuoso that use OpenAccess.

The standard vias that are defined in the technology provide the
default definitions for a via structure.  Although commonly
instantiated directly, more commonly variations are implemented. 
There are a number of parameters that define the via, and these can be
changed by the user to produce a variant most suitable in the context
where it will be used.  For example, the cut can be arrayed when lower
contact resistance is required.

The mechanism is similar to a parameterized cell (pcell).  The
standard vias defined in the technology can be considered as the
super-masters.  When a via of a certain configuration is requested, a
``sub-master'' cell for that configuration is created in memory, if it
hasn't been created previously.  The instances of the via will
reference that sub-master.  Like pcells, the masters are not written
to disk.  Instead, when a file containing via placements is read, the
via sub-masters are created in memory as needed.

An exception is when shipping a layout to another system, such as to a
mask vendor.  The {\cb Export Control} panel from the {\cb Convert
Menu} is used for this purpose.  If the {\cb Strip For Export} check
box is checked or equivalently if the {\et StripForExport} variable is
set, which should be true in this situation, the via (and pcell)
sub-masters are included in the layout file.  The foreign system will
see these as ordinary cells.  The {\cb Include standard via cell
sub-masters} check box or equivalently the {\et ViaKeepSubMasters}
variable will likewise cause inclusion of the via sub-masters in
output when set.

A standard via definition provides values for a number of parameters. 
Of these, the numerical values can be changed by the user to form a
variant.  The layers involved are immutable.  Each standard via
definition has a unique name assigned in the technology.  This name
can be any text which is suitable as a cell name.  One convention is
to use the layer names of the two conductors, top layer first,
separated by an underscore, e.g., ``{\vt M2\_M1}''.  The parameters
and their effects are described with the {\cb Via Creation} panel,
from which the parameters can be set, and variants created and placed.

\subsection{The Standard Via Property String}
\label{stdviaprp}

The {\et stdvia} property (number 7160) is applied to standard via
instances and sub-masters.
%\ifoa
The OpenAccess translator will transparently convert these to the
corresponding OpenAccess forms when writing to OpenAccess, and {\it
vice-versa\/}.
%\fi
A string with very similar format to the property string is used by
the {\vt OpenViaSubMaster} script function.  The property string
syntax is described here.

There are actually two formats, that will be referred to as the old
and new formats.  The old format uses OpenAccess keywords and is
friendly for humans, the new format uses a code and is more compact. 
{\Xic} will always write the new format, but will read either format.

The property string consists of one or more space-separated text
tokens.  In either case, the first token is the name of the standard
via, as given in the definition in the technology file.  The remaining
terms represent the numerical parameters that are different from the
defaults given in the standard via definition.  There need not be any
additional tokens, in which case the via has all default values.  More
commonly, tokens follow the via name that provide alternate values.

In the old format, a token takes one of the forms
\begin{quote}
{\it keyword\/}{\vt :}{\it value\/}\\
{\it keyword\/}{\vt :}{\it value\/}{\vt ,}{\it value}
\end{quote}
The {\it value} indicates an integer representing a dimension in
internal units.

The new format assigns each numeric value a lower-case letter.  A
token consists of the letter, followed immediately by the numeric
value in nanometers.  The number is printed in a format which removes
trailing zeros and decimal points.

\begin{tabular}{|l|l|} \hline
\bf new format key letter(s) & \bf old format keyword\\ \hline\hline
\vt a &   \vt CutWidth\\ \hline
\vt b &   \vt CutHeight\\ \hline
\vt c &   \vt CutRows\\ \hline
\vt d &   \vt CutColumns\\ \hline
\vt e,f & \vt CutSpacing\\ \hline
\vt g,h & \vt Layer1Enc\\ \hline
\vt i,j & \vt Layer1Off\\ \hline
\vt k,l & \vt Layer2End\\ \hline
\vt m,n & \vt Layer2Off\\ \hline
\vt o,p & \vt OriginOff\\ \hline
\vt q,r & \vt Implant1Enc\\ \hline
\vt s,t & \vt Implant2Enc\\ \hline
\end{tabular}

The new and old formats can {\bf not} be mixed, all tokens must follow
one format or the other.  The cases with two letters correspond to the
keywords with two values, and the values represent dimensions in the X
and Y directions.

Examples:\\
\begin{quote}\vt
M2\_M1 CutRows:2 CutColumns:2 Layer1Enc:40,60\\
M2\_M1 c2 d2 h60
\end{quote}

The two strings are equivalent if 1) the database resolution is 1000
so that the internal unit is nanomenters, and 2) the default layer 1
enclosure in the X direction is 40nm.

When a sub-master is created, it is given a cell name that is the same
as a new format property string with the space stripped out, and the
characters `$-$' (minus) and `.' (period) replaced by `{\vt m}' and
`{\vt p}', respectively.

The {\vt OpenViaSubMaster} script function takes a string in almost
the same format, the only difference is that the via name token is not
present.  Effectively, the via name is passed as the first argument,
and the rest of the string (if anything) is passed as the second
argument.  Either new or old format is acceptable.

